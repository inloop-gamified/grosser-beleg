
@inproceedings{prause_gamification_2015,
	address = {Bergamo, Italy},
	series = {{ESEC}/{FSE} 2015},
	title = {Gamification for enforcing coding conventions},
	isbn = {978-1-4503-3675-8},
	url = {https://doi.org/10.1145/2786805.2786806},
	doi = {10.1145/2786805.2786806},
	abstract = {Software is a knowledge intensive product, which can only evolve if there is effective and efficient information exchange between developers. Complying to coding conventions improves information exchange by improving the readability of source code. However, without some form of enforcement, compliance to coding conventions is limited. We look at the problem of information exchange in code and propose gamification as a way to motivate developers to invest in compliance. Our concept consists of a technical prototype and its integration into a Scrum environment. By means of two experiments with agile software teams and subsequent surveys, we show that gamification can effectively improve adherence to coding conventions.},
	urldate = {2020-05-18},
	booktitle = {Proceedings of the 2015 10th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Prause, Christian R. and Jarke, Matthias},
	month = aug,
	year = {2015},
	keywords = {code style, experiment, gamification, software quality},
	pages = {649--660},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/VWSAT769/Prause und Jarke - 2015 - Gamification for enforcing coding conventions.pdf:application/pdf}
}

@inproceedings{dietz_teaching_2018,
	series = {{CEUR} {Workshop} {Proceedings}},
	title = {Teaching {Clean} {Code}},
	volume = {2066},
	url = {http://ceur-ws.org/Vol-2066/isee2018paper06.pdf},
	urldate = {2020-05-18},
	booktitle = {Combined {Proceedings} of the {Workshops} of the {German} {Software} {Engineering} {Conference} 2018 ({SE} 2018), {Ulm}, {Germany}, {March} 06, 2018},
	publisher = {CEUR-WS.org},
	author = {Dietz, Linus W. and Manner, Johannes and Harrer, Simon and Lenhard, Jörg},
	editor = {Krusche, Stephan and Schneider, Kurt and Kuhrmann, Marco and Heinrich, Robert and Jung, Reiner and Konersmann, Marco and Schmieders, Eric and Striewe, Michael and Strickroth, Sven and Lucke, Ulrike and Lichter, Horst and Riehle, Dirk and Steffens, Andreas and Höttger, Robert and Teßmer, Jörg and Steghöfer, Jan-Philipp},
	year = {2018},
	pages = {24--27}
}

@inproceedings{morgenstern_continuous_2018,
	series = {{CEUR} {Workshop} {Proceedings}},
	title = {Continuous {Publishing} of {Online} {Programming} {Assignments} with {INLOOP}},
	volume = {2066},
	url = {http://ceur-ws.org/Vol-2066/isee2018paper08.pdf},
	urldate = {2020-05-18},
	booktitle = {Combined {Proceedings} of the {Workshops} of the {German} {Software} {Engineering} {Conference} 2018 ({SE} 2018), {Ulm}, {Germany}, {March} 06, 2018},
	publisher = {CEUR-WS.org},
	author = {Morgenstern, Martin and Demuth, Birgit},
	editor = {Krusche, Stephan and Schneider, Kurt and Kuhrmann, Marco and Heinrich, Robert and Jung, Reiner and Konersmann, Marco and Schmieders, Eric and Striewe, Michael and Strickroth, Sven and Lucke, Ulrike and Lichter, Horst and Riehle, Dirk and Steffens, Andreas and Höttger, Robert and Teßmer, Jörg and Steghöfer, Jan-Philipp},
	year = {2018},
	pages = {32--33}
}

@inproceedings{akpolat_enhancing_2014,
	title = {Enhancing software engineering student team engagement in a high-intensity extreme programming course using gamification},
	doi = {10.1109/CSEET.2014.6816792},
	abstract = {The use of game thinking and game mechanics in non-gaming context is becoming more and more popular. This has been known as gamification. Recent studies have shown that this attempt seems very promising in different areas. In this paper we explore the value of gamification in a software development team. This paper describes one approach to add gamification into the software development process in teams of ten students each. We have conducted a gamification study with 50 volunteer students. In this paper we explain the rules, terms, and findings of this study.},
	booktitle = {2014 {IEEE} 27th {Conference} on {Software} {Engineering} {Education} and {Training} ({CSEE} {T})},
	author = {Akpolat, Bilal Sercan and Slany, Wolfgang},
	month = apr,
	year = {2014},
	note = {ISSN: 2377-570X},
	keywords = {gamification, Atmospheric measurements, computer science education, educational courses, Educational institutions, game mechanics, game thinking, Games, high-intensity extreme programming course, nongaming context, Particle measurements, programming, Programming, Software, software development process, software development team, software engineering, software engineering student team engagement, team working},
	pages = {149--153},
	file = {IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/7PN3Y9ZX/6816792.html:text/html;Full Text PDF:/Users/philippmatthes/Zotero/storage/FUFW72JG/Akpolat und Slany - 2014 - Enhancing software engineering student team engage.pdf:application/pdf}
}

@inproceedings{souza_gamification_2017,
	title = {Gamification in {Software} {Engineering} {Education}: {An} {Empirical} {Study}},
	shorttitle = {Gamification in {Software} {Engineering} {Education}},
	doi = {10.1109/CSEET.2017.51},
	abstract = {Gamification is the application of game-design elements and game principles in non-game contexts. Gamification is a relatively new trend that has been applied in various domains, including Software Engineering. However, few studies have explored the potential of gamification in the context of Software Engineering education. In this paper, we describe an experience of introducing two game elements, namely badges and leaderboards, in an introductory Software Engineering course. Our goal is to evaluate the students' perception on the impact of these elements in their motivation towards the course. We conducted a survey with 18 participants for quantitative results, and a series of interviews with 6 participants for a qualitative perspective on the results. We observed that students received badges positively, while there were mixed results about the use of leaderboards in our strategy. The main benefits on the use of these elements is that they provide social recognition rewards for students. In addition, the use of badges establishes further objectives for students to strive for, besides grades and approval.},
	booktitle = {2017 {IEEE} 30th {Conference} on {Software} {Engineering} {Education} and {Training} ({CSEE} {T})},
	author = {Souza, Mauricio Ronny de Almeida and Constantino, Kattiana Fernandes and Veado, Lucas Furtini and Figueiredo, Eduardo Magno Lages},
	month = nov,
	year = {2017},
	note = {ISSN: 2377-570X},
	keywords = {gamification, computer science education, educational courses, Games, Software, software engineering, badges, computer aided instruction, computer games, Computer science, Education, game principles, game-design elements, Gamification, Interviews, introductory Software Engineering course, leaderboards, nongame contexts, social aspects of automation, Software engineering, Software Engineering education, Software Engineering Education, student perception},
	pages = {276--284},
	file = {IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/IRJCWYFQ/authors.html:text/html}
}

@inproceedings{fraser_gamification_2017,
	title = {Gamification of {Software} {Testing}},
	doi = {10.1109/AST.2017.20},
	abstract = {Writing good software tests is difficult, not every software developer's favorite occupation, and not a prominent aspect in programming education. However, human involvement in testing is unavoidable: What makes a test good is often down to intuition; what makes a test useful depends on an understanding of the program context; what makes a test find bugs depends on understanding the intended program behaviour. Because the consequences of insufficient testing can be dire, this paper explores a new angle to address the testing problem: Gamification is the approach of converting potentially tedious or boring tasks to components of entertaining gameplay, where the competitive nature of humans motivates them to compete and excel. By applying gamification concepts to software testing, there is potential to fundamentally change software testing in several ways: First, gamification can help to overcome deficiencies in education, where testing is a highly neglected topic. Second, gamification engages practitioners in testing tasks they would otherwise neglect, and gets them to use advanced testing tools and techniques they would otherwise not consider. Finally, gamification makes it possible to crowdsource complex testing tasks through games with a purpose. Collectively, these applications of gamification have the potential to substantially improve software testing practice, and thus software quality.},
	booktitle = {2017 {IEEE}/{ACM} 12th {International} {Workshop} on {Automation} of {Software} {Testing} ({AST})},
	author = {Fraser, Gordon},
	month = may,
	year = {2017},
	keywords = {software quality, computer science education, Games, Software, computer games, Education, complex testing task crowdsourcing, gameplay, program behaviour, program debugging, program testing, programming education, Programming profession, software bugs, software quality improvement, Software testing, software testing gamification},
	pages = {2--7},
	file = {IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/W34RTH2V/7962323.html:text/html}
}

@article{sheth_increasing_2012,
	title = {Increasing {Student} {Engagement} in {Software} {Engineering} with {Gamification}},
	url = {https://doi.org/10.7916/D8H99DF0},
	doi = {10.7916/D8H99DF0},
	abstract = {Gamification, or the use of game elements in non-game contexts, has become an increasingly popular approach to increasing end-user engagement in many contexts, including employee productivity, sales, recycling, and education. Our preliminary work has shown that gamification can be used to boost student engagement and learning in basic software testing. We seek to expand our gamified software engineering approach to motivate other software engineering best practices. We propose to build a game layer on top of traditional continuous integration technologies to increase student engagement in development, documentation, bug reporting, and test coverage. This poster describes to our approach and presents some early results showing feasability.},
	language = {en},
	urldate = {2020-05-18},
	author = {Sheth, Swapneel Kalpesh and Bell, Jonathan Schaffer and Kaiser, Gail E.},
	year = {2012},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/54UWAHKY/Sheth et al. - 2012 - Increasing Student Engagement in Software Engineer.pdf:application/pdf;Snapshot:/Users/philippmatthes/Zotero/storage/EPTHJKVE/D8H99DF0.html:text/html}
}

@inproceedings{haendler_serious_2019,
	title = {Serious {Refactoring} {Games}},
	copyright = {Attribution-NonCommercial-NoDerivatives 4.0 International},
	isbn = {978-0-9981331-2-6},
	url = {http://scholarspace.manoa.hawaii.edu/handle/10125/60207},
	doi = {10.24251/HICSS.2019.927},
	abstract = {Software design issues can severely impede software development and maintenance. Thus, it is important for the success of software projects that developers are aware of bad smells in code artifacts and improve their skills to reduce these issues via refactoring. However, software refactoring is a complex activity and involves multiple tasks and aspects. Therefore, imparting competences for identifying bad smells and refactoring code efficiently is challenging for software engineering education and training.  The approaches proposed for teaching software refactoring in recent years mostly concentrate on small and artificial tasks and fall short in terms of higher level competences, such as analysis and evaluation. In this paper, we investigate the possibilities and challenges of designing serious games for software refactoring on real-world code artifacts. In particular, we propose a game design, where students can compete either against a predefined benchmark (technical debt) or against each other. In addition, we describe a lightweight architecture as the technical foundation for the game design that integrates pre-existing analysis tools such as test frameworks and software-quality analyzers. Finally, we provide an exemplary game scenario to illustrate the application of serious games in a learning setting.},
	language = {eng},
	urldate = {2020-05-18},
	author = {Haendler, Thorsten and Neumann, Gustaf},
	month = jan,
	year = {2019},
	note = {Accepted: 2019-01-03T01:03:48Z},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/JUYQZ7IT/Haendler und Neumann - 2019 - Serious Refactoring Games.pdf:application/pdf;Snapshot:/Users/philippmatthes/Zotero/storage/5M4TZHSG/60207.html:text/html}
}

@misc{borcea-pfitzmann_diplom_nodate,
	type = {Document},
	title = {Diplom {Informatik} (modularisiert)},
	url = {?set_language=de},
	abstract = {Erwartungen an unsere Studierenden

Der Diplomstudiengang Informatik wendet sich an mathematisch-naturwissenschaftlich begabte und besonders motivierte Abiturienten mit dem Ziel, die …},
	language = {de},
	urldate = {2020-05-23},
	journal = {TU Dresden},
	author = {Borcea-Pfitzmann, Katrin},
	note = {Library Catalog: tu-dresden.de},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/93PG8GJE/diplom-informatik.html:text/html}
}

@inproceedings{deterding_game_2011,
	address = {Tampere, Finland},
	series = {{MindTrek} '11},
	title = {From game design elements to gamefulness: defining "gamification"},
	isbn = {978-1-4503-0816-8},
	shorttitle = {From game design elements to gamefulness},
	url = {https://doi.org/10.1145/2181037.2181040},
	doi = {10.1145/2181037.2181040},
	abstract = {Recent years have seen a rapid proliferation of mass-market consumer software that takes inspiration from video games. Usually summarized as "gamification", this trend connects to a sizeable body of existing concepts and research in human-computer interaction and game studies, such as serious games, pervasive games, alternate reality games, or playful design. However, it is not clear how "gamification" relates to these, whether it denotes a novel phenomenon, and how to define it. Thus, in this paper we investigate "gamification" and the historical origins of the term in relation to precursors and similar concepts. It is suggested that "gamified" applications provide insight into novel, gameful phenomena complementary to playful phenomena. Based on our research, we propose a definition of "gamification" as the use of game design elements in non-game contexts.},
	urldate = {2020-05-24},
	booktitle = {Proceedings of the 15th {International} {Academic} {MindTrek} {Conference}: {Envisioning} {Future} {Media} {Environments}},
	publisher = {Association for Computing Machinery},
	author = {Deterding, Sebastian and Dixon, Dan and Khaled, Rilla and Nacke, Lennart},
	month = sep,
	year = {2011},
	keywords = {gamification, alternate reality games, game-based technologies, gameful design, gamefulness, games, pervasive games, play, playful design, playfulness, serious games},
	pages = {9--15},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/4QFLU4YG/Deterding et al. - 2011 - From game design elements to gamefulness defining.pdf:application/pdf}
}

@inproceedings{mekler_points_2013,
	address = {Toronto, Ontario, Canada},
	series = {Gamification '13},
	title = {Do points, levels and leaderboards harm intrinsic motivation? an empirical analysis of common gamification elements},
	isbn = {978-1-4503-2815-9},
	shorttitle = {Do points, levels and leaderboards harm intrinsic motivation?},
	url = {https://doi.org/10.1145/2583008.2583017},
	doi = {10.1145/2583008.2583017},
	abstract = {It is heavily debated within the gamification community whether specific game elements may actually undermine users' intrinsic motivation. This online experiment examined the effects of three commonly employed game design elements -- points, leaderboard, levels -- on users' performance, intrinsic motivation, perceived autonomy and competence in an image annotation task. Implementation of these game elements significantly increased performance, but did not affect perceived autonomy, competence or intrinsic motivation. Our findings suggest that points, levels and leaderboards by themselves neither make nor break users' intrinsic motivation in non-game contexts. Instead, it is assumed that they act as progress indicators, guiding and enhancing user performance. While more research on the contextual factors that may potentially mediate the effects of game elements on intrinsic motivation is required, it seems that the implementation of points, levels, and leaderboards is a viable means to promote specific user behavior in non-game contexts.},
	urldate = {2020-05-24},
	booktitle = {Proceedings of the {First} {International} {Conference} on {Gameful} {Design}, {Research}, and {Applications}},
	publisher = {Association for Computing Machinery},
	author = {Mekler, Elisa D. and Brühlmann, Florian and Opwis, Klaus and Tuch, Alexandre N.},
	month = oct,
	year = {2013},
	keywords = {gamification, gameful design, game design elements, motivation},
	pages = {66--73},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/L74XDWK8/Mekler et al. - 2013 - Do points, levels and leaderboards harm intrinsic .pdf:application/pdf}
}

@article{sailer_how_2017,
	title = {How gamification motivates: {An} experimental study of the effects of specific game design elements on psychological need satisfaction},
	volume = {69},
	issn = {0747-5632},
	shorttitle = {How gamification motivates},
	url = {http://www.sciencedirect.com/science/article/pii/S074756321630855X},
	doi = {10.1016/j.chb.2016.12.033},
	abstract = {The main aim of gamification, i.e. the implementation of game design elements in real-world contexts for non-gaming purposes, is to foster human motivation and performance in regard to a given activity. Previous research, although not entirely conclusive, generally supports the hypothesis underlying this aim. However, previous studies have often treated gamification as a generic construct, neglecting the fact that there are many different game design elements which can result in very diverse applications. Based on a self-determination theory framework, we present the results of a randomized controlled study that used an online simulation environment. We deliberately varied different configurations of game design elements, and analysed them in regard to their effect on the fulfilment of basic psychological needs. Our results show that badges, leaderboards, and performance graphs positively affect competence need satisfaction, as well as perceived task meaningfulness, while avatars, meaningful stories, and teammates affect experiences of social relatedness. Perceived decision freedom, however, could not be affected as intended. We interpret these findings as general support for our main hypothesis that gamification is not effective per se, but that specific game design elements have specific psychological effects. Consequences for further research, in particular the importance of treatment checks, are discussed.},
	language = {en},
	urldate = {2020-05-24},
	journal = {Computers in Human Behavior},
	author = {Sailer, Michael and Hense, Jan Ulrich and Mayr, Sarah Katharina and Mandl, Heinz},
	month = apr,
	year = {2017},
	keywords = {Gamification, Game design elements, Motivation, Psychological need satisfaction, Self-determination theory, Simulation},
	pages = {371--380},
	file = {ScienceDirect Snapshot:/Users/philippmatthes/Zotero/storage/5UWSGZ6M/S074756321630855X.html:text/html;ScienceDirect Full Text PDF:/Users/philippmatthes/Zotero/storage/4QVBIZPX/Sailer et al. - 2017 - How gamification motivates An experimental study .pdf:application/pdf}
}

@inproceedings{antin_badges_2011,
	title = {Badges in {Social} {Media}: {A} {Social} {Psychological} {Perspective}},
	shorttitle = {Badges in {Social} {Media}},
	author = {Antin, Judd and Churchill, Elizabeth},
	month = jan,
	year = {2011}
}

@article{wang_game_2012,
	title = {Game {Reward} {Systems}: {Gaming} {Experiences} and {Social} {Meanings}},
	shorttitle = {Game {Reward} {Systems}},
	abstract = {The authors give an overview of how various video game reward systems provide positive experiences to players, and propose classifications for rewards and reward characteristics for further analysis. We also discuss what reward systems encourage players to do, and describe how they provide fun even before players receive their rewards. Next, we describe how game reward systems can be used to motivate or change behaviors in the physical world. One of our main suggestions is that players can have fun with both rewards and reward mechanisms—enjoying rewards while reacting to the motivation that such rewards provide. Based on relevant psychological theories, we discuss how reward mechanisms foster intrinsic motivation while giving extrinsic rewards. We think that reward systems and mechanisms in modern digital games provide social meaning for players primarily through motivation, enhanced status within gaming societies, and the use of rewards as social tools.},
	author = {Wang, Hao and Sun, Chuen-Tsai},
	month = may,
	year = {2012},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/H7Q59W6F/Wang und Sun - 2012 - Game Reward Systems Gaming Experiences and Social.pdf:application/pdf}
}

@article{landers_gamification_2018,
	title = {Gamification {Science}, {Its} {History} and {Future}: {Definitions} and a {Research} {Agenda}},
	volume = {49},
	issn = {1046-8781},
	shorttitle = {Gamification {Science}, {Its} {History} and {Future}},
	url = {https://doi.org/10.1177/1046878118774385},
	doi = {10.1177/1046878118774385},
	abstract = {Background. Definitions of gamification tend to vary by person, both in industry and within academia. One particularly popular lay interpretation, introduced and popularized by Ian Bogost, and reiterated by Jan Klabbers, is that gamification is “bullshit” and “exploitationware.” They describe gamification as a marketing term or business practice invented to sell products rather than to represent a real and unique phenomenon relevant to a nascent game science. However, this view is an oversimplification, one which ignores a growing body of theory development and empirical research on gamification within a post-positivist epistemology. In fact, because gamification is so much more outcome-focused than general game design, current gamification research in many ways has a stronger footing in modern social science than much games research does., Aim. In this article, to address common misunderstandings like these, we describe the philosophical underpinnings of modern gamification research, define the relationship between games and gamification, define and situate gamification science as a subdiscipline of game science, and explicate a six-element framework of major concerns within gamification science: predictor constructs, criterion constructs, mediator constructs, moderator constructs, design processes, and research methods. This framework is also presented diagrammatically as a causal path model., Conclusion. Gamification science refers to the development of theories of gamification design and their empirical evaluation within a post-positivist epistemology. The goal of gamification scientist-practitioners should be to understand how to best meet organizational goals through the design of gamification interventions, drawing upon insights derived from both gamification science and games research more broadly.},
	language = {en},
	number = {3},
	urldate = {2020-05-25},
	journal = {Simulation \& Gaming},
	author = {Landers, Richard N. and Auer, Elena M. and Collmus, Andrew B. and Armstrong, Michael B.},
	month = jun,
	year = {2018},
	note = {Publisher: SAGE Publications Inc},
	pages = {315--337},
	file = {SAGE PDF Full Text:/Users/philippmatthes/Zotero/storage/I9LSNINL/Landers et al. - 2018 - Gamification Science, Its History and Future Defi.pdf:application/pdf}
}

@article{louridas_static_2006,
	title = {Static code analysis},
	volume = {23},
	issn = {1937-4194},
	doi = {10.1109/MS.2006.114},
	abstract = {Programmers usually employ static checkers, it checks our programs for errors without executing them, in a process called static code analysis. In this way, it works with a program that has an initial indication of correctness (because it compiles) and try to avoid well-known traps and pitfalls before measuring it against its specifications (when it's tested). We use FindBugs, a popular open source static code checker for Java. Static code checkers in Java come in two flavors: those that work directly on the program source code and those that work on the compiled bytecode. Although each code checker works in its own way, most share some basic traits. They read the program and construct some model of it, a kind of abstract representation that they can use for matching the error patterns they recognize. They also perform some kind of data-flow analysis, trying to infer the possible values that variables might have at certain points in the program. Data-flow analysis is especially important for vulnerability checking, an increasingly important area for code checkers},
	number = {4},
	journal = {IEEE Software},
	author = {Louridas, P.},
	month = jul,
	year = {2006},
	note = {Conference Name: IEEE Software},
	keywords = {program debugging, program testing, Software testing, Computer bugs, data flow analysis, data-flow analysis, debugging, FindBugs, Insects, Inspection, Java, open source code checker, Open source software, program verification, public domain software, software testing, static checkers, static code analysis},
	pages = {58--61}
}

@article{kruchten_technical_2012,
	title = {Technical {Debt}: {From} {Metaphor} to {Theory} and {Practice}},
	volume = {29},
	issn = {1937-4194},
	shorttitle = {Technical {Debt}},
	doi = {10.1109/MS.2012.167},
	abstract = {The metaphor of technical debt in software development was introduced two decades ago to explain to nontechnical stakeholders the need for what we call now "refactoring." As the term is being used to describe a wide range of phenomena, this paper proposes an organization of the technical debt landscape, and introduces the papers on technical debt contained in the issue.},
	number = {6},
	journal = {IEEE Software},
	author = {Kruchten, Philippe and Nord, Robert L. and Ozkaya, Ipek},
	month = nov,
	year = {2012},
	note = {Conference Name: IEEE Software},
	keywords = {software quality, evolvability, Investments, maintainability, refactoring, Risk management, Software maintenance, Software quality, Sofware testing, technical debt},
	pages = {18--21},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/U8WYKYN9/Kruchten et al. - 2012 - Technical Debt From Metaphor to Theory and Practi.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/4IU6QA9Q/6336722.html:text/html}
}

@inproceedings{letouzey_sqale_2012,
	title = {The {SQALE} method for evaluating {Technical} {Debt}},
	doi = {10.1109/MTD.2012.6225997},
	abstract = {This paper presents the SQALE (Software Quality Assessment Based on Lifecycle Expectations) method. We describe its Quality Model and Analysis Model which is used to estimate the Quality and the Technical Debt of an application source code. We provide recommendations and guidelines for using the SQALE indicators in order to analyse the structure and the impact of the Technical Debt.},
	booktitle = {2012 {Third} {International} {Workshop} on {Managing} {Technical} {Debt} ({MTD})},
	author = {Letouzey, Jean-Louis},
	month = jun,
	year = {2012},
	keywords = {software quality, Software, technical debt, analysis model, Analytical models, application source code, Indexes, lifecycle expectations, Organizations, Portfolios, quality, quality model, Reliability, software maintenance, software quality assessment, software reliability, source code, SQALE, SQALE method, Standards organizations, Technical Debt},
	pages = {31--36},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/7ME8RMTL/Letouzey - 2012 - The SQALE method for evaluating Technical Debt.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/MZGI9P9H/6225997.html:text/html}
}

@article{li_systematic_2014,
	title = {A {Systematic} {Mapping} {Study} on {Technical} {Debt} and {Its} {Management}},
	doi = {10.1016/j.jss.2014.12.027},
	abstract = {Context: Technical debt (TD) is a metaphor reflecting technical compromises that can yield short-term benefit but may hurt the long-term health of a software system. Objective: This work aims at collecting studies on TD and TD management (TDM), and making a classification and thematic analysis on these studies, to obtain a comprehensive understanding on the TD concept and an overview on the current state of research on TDM. Method: A systematic mapping study was performed to identify and analyze research on TD and its management, covering publications between 1992 and 2013. Results: Ninety-four studies were finally selected. TD was classified into ten types, eight TDM activities were identified, and twenty-nine tools for TDM were collected. Conclusions: The term “debt” has been used in different ways by different people, which leads to ambiguous interpretation of the term. Code-related TD and its management have gained the most attention. There is a need for more empirical studies with high-quality evidence on the whole TDM process and on the application of specific TDM approaches in industrial settings. Moreover, dedicated TDM tools are needed for managing various types of TD in the whole TDM process.},
	journal = {Journal of Systems and Software},
	author = {Li, Zengyang and Avgeriou, Paris and Liang, Peng},
	month = dec,
	year = {2014},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/SDDGY699/Li et al. - 2014 - A Systematic Mapping Study on Technical Debt and I.pdf:application/pdf}
}

@misc{technical_committee_isoiec_jtc_1sc_7_software_and_systems_engineering_isoiec_2001,
	title = {{ISO}/{IEC} 9126-1:2001},
	shorttitle = {{ISO}/{IEC} 9126-1},
	url = {https://www.iso.org/cms/render/live/en/sites/isoorg/contents/data/standard/02/27/22749.html},
	abstract = {Software engineering — Product quality — Part 1: Quality model},
	language = {en},
	urldate = {2020-05-27},
	journal = {www.iso.org},
	author = {Technical Committee ISO/IEC JTC 1/SC 7 Software {and} systems engineering},
	year = {2001},
	note = {Library Catalog: www.iso.org},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/4P5X9L6Y/22749.html:text/html}
}

@misc{technical_committee_isoiec_jtc_1sc_7_software_and_systems_engineering_isoiec_2011,
	title = {{ISO}/{IEC} 25010:2011},
	shorttitle = {{ISO}/{IEC} 25010},
	url = {https://www.iso.org/cms/render/live/en/sites/isoorg/contents/data/standard/03/57/35733.html},
	abstract = {Systems and software engineering — Systems and software Quality Requirements and Evaluation (SQuaRE) — System and software quality models},
	language = {en},
	urldate = {2020-05-27},
	journal = {www.iso.org},
	author = {{Technical Committee ISO/IEC JTC 1/SC 7 Software and systems engineering}},
	year = {2011},
	note = {Library Catalog: www.iso.org},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/X9UDWQR2/35733.html:text/html}
}

@article{stamelos_code_2002,
	title = {Code quality analysis in open source software development},
	volume = {12},
	issn = {1365-2575},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1046/j.1365-2575.2002.00117.x},
	doi = {10.1046/j.1365-2575.2002.00117.x},
	abstract = {Proponents of open source style software development claim that better software is produced using this model compared with the traditional closed model. However, there is little empirical evidence in support of these claims. In this paper, we present the results of a pilot case study aiming: (a) to understand the implications of structural quality; and (b) to figure out the benefits of structural quality analysis of the code delivered by open source style development. To this end, we have measured quality characteristics of 100 applications written for Linux, using a software measurement tool, and compared the results with the industrial standard that is proposed by the tool. Another target of this case study was to investigate the issue of modularity in open source as this characteristic is being considered crucial by the proponents of open source for this type of software development. We have empirically assessed the relationship between the size of the application components and the delivered quality measured through user satisfaction. We have determined that, up to a certain extent, the average component size of an application is negatively related to the user satisfaction for this application.},
	language = {en},
	number = {1},
	urldate = {2020-05-27},
	journal = {Information Systems Journal},
	author = {Stamelos, Ioannis and Angelis, Lefteris and Oikonomou, Apostolos and Bleris, Georgios L.},
	year = {2002},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1046/j.1365-2575.2002.00117.x},
	keywords = {Code quality characteristics, open source development, software measurement, structural code analysis, user satisfaction},
	pages = {43--60},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/ZY2JNGQT/j.1365-2575.2002.00117.html:text/html;Full Text PDF:/Users/philippmatthes/Zotero/storage/Q9LHVCVA/Stamelos et al. - 2002 - Code quality analysis in open source software deve.pdf:application/pdf}
}

@article{rosenberg_software_nodate,
	title = {Software {Quality} {Metrics} for {Object}-{Oriented} {Environments}},
	language = {en},
	author = {Rosenberg, Dr Linda H and Hyatt, Lawrence E},
	pages = {6},
	file = {Rosenberg und Hyatt - Software Quality Metrics for Object-Oriented Envir.pdf:/Users/philippmatthes/Zotero/storage/2AULXSC2/Rosenberg und Hyatt - Software Quality Metrics for Object-Oriented Envir.pdf:application/pdf}
}

@inproceedings{pantiuchina_improving_2018,
	title = {Improving {Code}: {The} ({Mis}) {Perception} of {Quality} {Metrics}},
	shorttitle = {Improving {Code}},
	doi = {10.1109/ICSME.2018.00017},
	abstract = {Code quality metrics are widely used to identify design flaws (e.g., code smells) as well as to act as fitness functions for refactoring recommenders. Both these applications imply a strong assumption: quality metrics are able to assess code quality as perceived by developers. Indeed, code smell detectors and refactoring recommenders should be able to identify design flaws/recommend refactorings that are meaningful from the developer's point-of-view. While such an assumption might look reasonable, there is limited empirical evidence supporting it. We aim at bridging this gap by empirically investigating whether quality metrics are able to capture code quality improvement as perceived by developers. While previous studies surveyed developers to investigate whether metrics align with their perception of code quality, we mine commits in which developers clearly state in the commit message their aim of improving one of four quality attributes: cohesion, coupling, code readability, and code complexity. Then, we use state-of-the-art metrics to assess the change brought by each of those commits to the specific quality attribute it targets. We found that, more often than not the considered quality metrics were not able to capture the quality improvement as perceived by developers (e.g., the developer states "improved the cohesion of class C", but no quality metric captures such an improvement).},
	booktitle = {2018 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	author = {Pantiuchina, Jevgenija and Lanza, Michele and Bavota, Gabriele},
	month = sep,
	year = {2018},
	note = {ISSN: 2576-3148},
	keywords = {software quality, Software, Java, public domain software, software maintenance, code complexity, code quality, code quality metrics, code readability, code smell detectors, Complexity theory, Couplings, design flaws, empirical study, Measurement, metrics, mis perception, refactoring recommenders, software metrics, state-of-the-art metrics, Task analysis, Tools},
	pages = {80--91},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/ZLXTVGQD/Pantiuchina et al. - 2018 - Improving Code The (Mis) Perception of Quality Me.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/NG3YIVTU/8530019.html:text/html}
}

@article{glass_frequently_2001,
	title = {Frequently forgotten fundamental facts about software engineering},
	volume = {18},
	issn = {1937-4194},
	doi = {10.1109/MS.2001.922739},
	number = {3},
	journal = {IEEE Software},
	author = {Glass, R.L.},
	month = may,
	year = {2001},
	note = {Conference Name: IEEE Software},
	keywords = {Software engineering, Programming profession, Software testing, Costs, Degradation, Ergonomics, Logic testing, Processor scheduling, Productivity, Software tools},
	pages = {112--111},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/LTQFUMDS/Glass - 2001 - Frequently forgotten fundamental facts about softw.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/54Q5WBLP/922739.html:text/html}
}

@book{chou_actionable_2019,
	title = {Actionable {Gamification}: {Beyond} {Points}, {Badges}, and {Leaderboards}},
	isbn = {978-1-83921-077-8},
	shorttitle = {Actionable {Gamification}},
	abstract = {Learn all about implementing a good gamification design into your products, workplace, and lifestyleKey FeaturesExplore what makes a game fun and engagingGain insight into the Octalysis Framework and its applicationsDiscover the potential of the Core Drives of gamification through real-world scenariosBook DescriptionEffective gamification is a combination of game design, game dynamics, user experience, and ROI-driving business implementations. This book explores the interplay between these disciplines and captures the core principles that contribute to a good gamification design.The book starts with an overview of the Octalysis Framework and the 8 Core Drives that can be used to build strategies around the various systems that make games engaging. As the book progresses, each chapter delves deep into a Core Drive, explaining its design and how it should be used. Finally, to apply all the concepts and techniques that you learn throughout, the book contains a brief showcase of using the Octalysis Framework to design a project experience from scratch.After reading this book, you'll have the knowledge and skills to enable the widespread adoption of good gamification and human-focused design in all types of industries.What you will learnDiscover ways to use gamification techniques in real-world situationsDesign fun, engaging, and rewarding experiences with OctalysisUnderstand what gamification means and how to categorize itLeverage the power of different Core Drives in your applicationsExplore how Left Brain and Right Brain Core Drives differ in motivation and design methodologiesExamine the fascinating intricacies of White Hat and Black Hat Core DrivesWho this book is forAnyone who wants to implement gamification principles and techniques into their products, workplace, and lifestyle will find this book useful.},
	language = {en},
	publisher = {Packt Publishing Ltd},
	author = {Chou, Yu-kai},
	month = dec,
	year = {2019},
	note = {Google-Books-ID: 9ZfBDwAAQBAJ},
	keywords = {Computers / General, Computers / Programming / Games, Computers / Programming / General}
}

@misc{technical_committee_isoiec_jtc_1sc_7_software_and_systems_engineering_isoiecieee_2017,
	title = {{ISO}/{IEC}/{IEEE} 12207:2017},
	shorttitle = {{ISO}/{IEC}/{IEEE} 12207},
	url = {https://www.iso.org/cms/render/live/en/sites/isoorg/contents/data/standard/06/37/63712.html},
	abstract = {Systems and software engineering — Software life cycle processes},
	language = {en},
	urldate = {2020-05-31},
	journal = {www.iso.org},
	author = {Technical Committee ISO/IEC JTC 1/SC 7 Software {and} systems engineering},
	year = {2017},
	note = {Library Catalog: www.iso.org},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/EZCMZ53M/63712.html:text/html}
}

@inproceedings{mora_literature_2015,
	title = {A {Literature} {Review} of {Gamification} {Design} {Frameworks}},
	doi = {10.1109/VS-GAMES.2015.7295760},
	abstract = {This paper presents a review of the literature on gamification design frameworks. Gamification, understood as the use of game design elements in other contexts for the purpose of engagement, has become a hot topic in the recent years. However, there's also a cautionary tale to be extracted from Gartner's reports on the topic: many gamification-based solutions fail because, mostly, they have been created on a whim, or mixing bits and pieces from game components, without a clear and formal design process. The application of a definite design framework aims to be a path to success. Therefore, before starting the gamification of a process, it is very important to know which frameworks or methods exist and their main characteristics. The present review synthesizes the process of gamification design for a successful engagement experience. This review categorizes existing approaches and provides an assessment of their main features, which may prove invaluable to developers of gamified solutions at different levels and scopes.},
	booktitle = {2015 7th {International} {Conference} on {Games} and {Virtual} {Worlds} for {Serious} {Applications} ({VS}-{Games})},
	author = {Mora, Alberto and Riera, Daniel and Gonzalez, Carina and Arnedo-Moreno, Joan},
	month = sep,
	year = {2015},
	keywords = {Games, game design elements, Bibliographies, Context, design framework, Design methodology, Ethics, formal design process, formal specification, game components, gamification design frameworks, gamification-based solutions, Proposals, serious games (computing)},
	pages = {1--8},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/KRW5NQX6/Mora et al. - 2015 - A Literature Review of Gamification Design Framewo.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/ADNDP36K/7295760.html:text/html}
}

@misc{rucks_erstellung_2017,
	title = {Erstellung eines (teil-)automatisierten {Bewertungssystems} für studentische {Projekte} im {Softwarepraktikum}},
	abstract = {Seit den ersten Ideen fu ̈r Metriken zur Bewertung der Qualita ̈t und Komplexita ̈t einer Software stehen diese auch in der Kritik. Es konnte nie erscho ̈pfend nachgewiesen werden, dass es eine Metrik gibt, die sich dafu ̈r wirklich gut eignet. So beschreibt Martin Shepperd bereits 1988 in seiner Kritik an McCabes zyklomatischer Komplexita ̈t, dass deren Zusammenhang mit der Wartbarkeit und Testbarkeit einer Software nicht gro ̈ßer ist, als der Zusammenhang zwischen diesen Merkmalen und der simplen Softwaregro ̈ße in Codezeilen [She88].
Auch spa ̈tere umfangreichere Untersuchungen verschiedenster Metriken konnten keine Metrik identifizieren, deren Korrelation zu einer Qualita ̈tseigenschaft des Codes signifikant gro ̈ßer ist als die Korrelation zwischen dieser Eigenschaft und der Gro ̈ße des Codes. Yossi Gil and Gal Lalouche kommen daher zu dem Schluss, dass die Gro ̈ße einer Software die einzige valide Codemetrik ist [GL17].
Es ist daher wenig u ̈berraschend, dass es auch im Rahmen dieser Arbeit nicht gelungen ist eine Menge von Codemetriken zu finden mit denen sich die Codequalita ̈t automatisiert bewerten la ̈sst. Mit dem Regelwerk und der darauf aufbauenden Conformity-Metrik ließ sich trotzdem ein verwendbarer Gewinn fu ̈r zuku ̈nftige Softwarepraktika erreichen. Der Satz von Horst Zuse mit dem der vorangegangene Große Beleg eingeleitet wurde, bleibt aber bestehen [Zus98]: "One number can not express softwarequality!"},
	language = {Deutsch},
	author = {Rucks, Jan},
	year = {2017},
	file = {Rucks - 2017 - Erstellung eines (teil-)automatisierten Bewertungs.pdf:/Users/philippmatthes/Zotero/storage/56UY2MFF/Rucks - 2017 - Erstellung eines (teil-)automatisierten Bewertungs.pdf:application/pdf}
}

@misc{noauthor_checkstyle_nodate,
	title = {checkstyle – {Checkstyle} 8.33},
	url = {https://checkstyle.sourceforge.io/},
	urldate = {2020-06-07},
	file = {checkstyle – Checkstyle 8.33:/Users/philippmatthes/Zotero/storage/TELTTBNY/checkstyle.sourceforge.io.html:text/html}
}

@misc{noauthor_pmd_nodate,
	title = {{PMD}},
	url = {https://pmd.github.io/},
	urldate = {2020-06-07},
	file = {PMD:/Users/philippmatthes/Zotero/storage/PSAW68KJ/pmd.github.io.html:text/html}
}

@misc{noauthor_findbugs_nodate,
	title = {{FindBugs}™ - {Find} {Bugs} in {Java} {Programs}},
	url = {http://findbugs.sourceforge.net/},
	urldate = {2020-06-07},
	file = {FindBugs™ - Find Bugs in Java Programs:/Users/philippmatthes/Zotero/storage/VCR5HZFU/findbugs.sourceforge.net.html:text/html}
}

@article{yang_expert_2019,
	title = {An {Expert} {System} for {Learning} {Software} {Engineering} {Knowledge} (with {Case} {Studies} in {Understanding} {Static} {Code} {Warning})},
	url = {http://arxiv.org/abs/1911.01387},
	abstract = {Knowledge-based systems reason over some knowledge base. Hence, an important issue for such systems is how to acquire the knowledge needed for their inference. This paper assesses active learning methods for acquiring knowledge for "static code warnings". Static code analysis is a widely-used methods for detecting bugs and security vulnerabilities in software systems. As software becomes more complex, analysis tools also report lists of increasingly complex warnings that developers need to address on a daily basis. Such static code analysis tools often usually over-cautious; i.e. they often offer many warns about spurious issues. Previous research work shows that about 35\% to 91\% warnings reported as bugs by SA tools are actually unactionable (i.e., warnings that would not be acted on by developers because they are falsely suggested as bugs). Experienced developers know which errors are important and which can be safely ignoredHow can we capture that experience? This paper reports on an incremental AI tool that watches humans reading false alarm reports. Using an incremental support vector machine mechanism, this AI tool can quickly learn to distinguish spurious false alarms from more serious matters that deserve further attention. In this work, nine open source projects are employed to evaluate our proposed model on the features extracted by previous researchers and identify the actionable warnings in priority order given by our algorithm. We observe that our model can identify over 90\% of actionable warnings when our methods tell humans to ignore 70 to 80\% of the warnings.},
	urldate = {2020-06-07},
	journal = {arXiv:1911.01387 [cs]},
	author = {Yang, Xueqi and Yu, Zhe and Wang, Junjie and Menzies, Tim},
	month = nov,
	year = {2019},
	note = {arXiv: 1911.01387},
	keywords = {Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:/Users/philippmatthes/Zotero/storage/BI8W2NZ9/Yang et al. - 2019 - An Expert System for Learning Software Engineering.pdf:application/pdf;arXiv.org Snapshot:/Users/philippmatthes/Zotero/storage/27FF47LM/1911.html:text/html}
}

@inproceedings{shen_efindbugs_2011,
	title = {{EFindBugs}: {Effective} {Error} {Ranking} for {FindBugs}},
	shorttitle = {{EFindBugs}},
	doi = {10.1109/ICST.2011.51},
	abstract = {Static analysis tools have been widely used to detect potential defects without executing programs. It helps programmers raise the awareness about subtle correctness issues in the early stage. However, static defect detection tools face the high false positive rate problem. Therefore, programmers have to spend a considerable amount of time on screening out real bugs from a large number of reported warnings, which is time-consuming and inefficient. To alleviate the above problem during the report inspection process, we present EFindBugs to employ an effective two-stage error ranking strategy that suppresses the false positives and ranks the true error reports on top, so that real bugs existing in the programs could be more easily found and fixed by the programmers. In the first stage, EFindBugs initializes the ranking by assigning predefined defect likelihood for each bug pattern and sorting the error reports by the defect likelihood in descending order. In the second stage, EFindBugs optimizes the initial ranking self-adaptively through the feedback from users. This optimization process is executed automatically and based on the correlations among error reports with the same bug pattern. Our experiment on three widely-used Java projects (AspectJ, Tomcat, and Axis) shows that our ranking strategy outperforms the original ranking in Find Bugs in terms of precision, recall and F1-score.},
	booktitle = {Verification and {Validation} 2011 {Fourth} {IEEE} {International} {Conference} on {Software} {Testing}},
	author = {Shen, Haihao and Fang, Jianhong and Zhao, Jianjun},
	month = mar,
	year = {2011},
	note = {ISSN: 2159-4848},
	keywords = {Software, program debugging, Computer bugs, FindBugs, Java, AspectJ, Axis, Correlation, Detectors, EFindBugs, error ranking, Error Ranking, error sorting, inspection, Java project, Optimization, optimization process, program diagnostics, report inspection process, software tools, Sorting, static analysis tool, Static Analysis Tool, static defect detection tool, Tomcat},
	pages = {299--308},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/93N9LD3L/Shen et al. - 2011 - EFindBugs Effective Error Ranking for FindBugs.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/CN8C4L2Y/5770619.html:text/html}
}

@inproceedings{allier_framework_2012,
	title = {A {Framework} to {Compare} {Alert} {Ranking} {Algorithms}},
	doi = {10.1109/WCRE.2012.37},
	abstract = {To improve software quality, rule checkers statically check if a software contains violations of good programming practices. On a real sized system, the alerts (rule violations detected by the tool) may be numbered by the thousands. Unfortunately, these tools generate a high proportion of "false alerts", which in the context of a specific software, should not be fixed. Huge numbers of false alerts may render impossible the finding and correction of "true alerts" and dissuade developers from using these tools. In order to overcome this problem, the literature provides different ranking methods that aim at computing the probability of an alert being a "true one". In this paper, we propose a framework for comparing these ranking algorithms and identify the best approach to rank alerts. We have selected six algorithms described in literature. For comparison, we use a benchmark covering two programming languages (Java and Smalltalk) and three rule checkers (Find Bug, PMD, Small Lint). Results show that the best ranking methods are based on the history of past alerts and their location. We could not identify any significant advantage in using statistical tools such as linear regression or Bayesian networks or ad-hoc methods.},
	author = {Allier, Simon and Anquetil, Nicolas and Hora, Andre and Ducasse, Stéphane},
	month = oct,
	year = {2012},
	pages = {277--285},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/RFGJ7Z9F/Allier et al. - 2012 - A Framework to Compare Alert Ranking Algorithms.pdf:application/pdf}
}

@inproceedings{anderson_taxonomy_2000,
	title = {A {Taxonomy} for {Learning}, {Teaching}, and {Assessing}: {A} {Revision} of {Bloom}'s {Taxonomy} of {Educational} {Objectives}},
	shorttitle = {A {Taxonomy} for {Learning}, {Teaching}, and {Assessing}},
	abstract = {List of Tables and Figures. Preface. Foreword. SECTION I: THE TAXONOMY, EDUCATIONAL OBJECTIVES AND STUDENT LEARNING. 1. Introduction. 2. The Structure, Specificity, and Problems of Objectives. SECTION II: THE REVISED TAXONOMY STRUCTURE. 3. The Taxonomy Table. 4. The Knowledge Dimension. 5. The Cognitive Process Dimension. SECTION III: THE TAXONOMY IN USE. 6. Using the Taxonomy Table. 7. Introduction to the Vignettes. 8. Nutrition Vignette. 9. Macbeth Vignette. 10. Addition Facts Vignette. 11. Parliamentary Acts Vignette. 12. Volcanoes? Here? Vignette. 13. Report Writing Vignette. 14. Addressing Long-standing Problems in Classroom Instruction. APPENDICES. Appendix A: Summary of the Changes from the Original Framework. Appendix B: Condensed Version of the Original Taxonomy of Educational Objectives: Cognitive Domain. References. Credits. Index.},
	author = {Anderson, Lorin W. and Krathwohl, David R. and Bloom, Benjamin S.},
	year = {2000},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/IPAQDNGN/Anderson et al. - 2000 - A Taxonomy for Learning, Teaching, and Assessing .pdf:application/pdf}
}

@book{harrer_java_2018,
	address = {Raleigh, North Carolina},
	title = {Java by {Comparison}: {Become} a {Java} {Craftsman} in 70 {Examples}},
	isbn = {978-1-68050-287-9},
	shorttitle = {Java by {Comparison}},
	abstract = {Write code that's clean, concise, and to the point: code that others will read with pleasure and reuse. Comparing your code to that of expert programmers is a great way to improve your coding skills. Get hands-on advice to level up your coding style through small and understandable examples that compare flawed code to an improved solution. Discover handy tips and tricks, as well as common bugs an experienced Java programmer needs to know. Make your way from a Java novice to a master craftsman.This book is a useful companion for anyone learning to write clean Java code. The authors introduce you to the fundamentals of becoming a software craftsman, by comparing pieces of problematic code with an improved version, to help you to develop a sense for clean code. This unique before-and-after approach teaches you to create clean Java code.Learn to keep your booleans in check, dodge formatting bugs, get rid of magic numbers, and use the right style of iteration. Write informative comments when needed, but avoid them when they are not. Improve the understandability of your code for others by following conventions and naming your objects accurately. Make your programs more robust with intelligent exception handling and learn to assert that everything works as expected using JUnit5 as your testing framework. Impress your peers with an elegant functional programming style and clear-cut object-oriented class design.Writing excellent code isn't just about implementing the functionality. It's about the small important details that make your code more readable, maintainable, flexible, robust, and faster. Java by Comparison teaches you to spot these details and trains you to become a better programmer.What You Need:You need a Java 8 compiler, a text editor, and a fresh mind.That's it.},
	language = {Englisch},
	publisher = {O'Reilly UK Ltd.},
	author = {Harrer, Simon and Lenhard, Jorg and Dietz, Linus},
	month = apr,
	year = {2018}
}

@article{lucero_playful_2014,
	title = {Playful or {Gameful}?: creating delightful user experiences},
	volume = {21},
	issn = {10725520},
	shorttitle = {Playful or {Gameful}?},
	url = {http://dl.acm.org/citation.cfm?doid=2608008.2590973},
	doi = {10.1145/2590973},
	language = {en},
	number = {3},
	urldate = {2020-06-21},
	journal = {interactions},
	author = {Lucero, Andrés and Karapanos, Evangelos and Arrasvuori, Juha and Korhonen, Hannu},
	month = may,
	year = {2014},
	pages = {34--39},
	file = {Lucero et al. - 2014 - Playful or Gameful creating delightful user expe.pdf:/Users/philippmatthes/Zotero/storage/ZX6C5UBQ/Lucero et al. - 2014 - Playful or Gameful creating delightful user expe.pdf:application/pdf;Full Text PDF:/Users/philippmatthes/Zotero/storage/X74M7CNA/Lucero et al. - 2014 - Playful or Gameful creating delightful user expe.pdf:application/pdf}
}

@inproceedings{krusche_artemis_2018,
	address = {Baltimore, Maryland, USA},
	series = {{SIGCSE} '18},
	title = {{ArTEMiS}: {An} {Automatic} {Assessment} {Management} {System} for {Interactive} {Learning}},
	isbn = {978-1-4503-5103-4},
	shorttitle = {{ArTEMiS}},
	url = {https://doi.org/10.1145/3159450.3159602},
	doi = {10.1145/3159450.3159602},
	abstract = {The increasing number of students in computer science courses leads to high efforts in manual assessment of exercises. Existing assessment systems are not designed for exercises with immediate feedback in large classes. In this paper, we present an AuTomated assEssment Management System for interactive learning. ArTEMiS assesses solutions to programming exercises automatically and provides instant feedback so that students can iteratively solve the exercise. It is open source and highly scalable based on version control, regression testing and continuous integration. ArTEMiS offers an online code editor with interactive exercise instructions, is programming language independent and applicable to a variety of computer science courses. By using it, students gain experiences in version control, dependency management and continuous integration. We used ArTEMiS in 3 university and 1 online courses and report about our experiences. We figured out that ArTEMiS is suitable for beginners, helps students to realize their progress and to gradually improve their solutions. It reduces the effort of instructors and enhances the learning experience of students.},
	urldate = {2020-06-21},
	booktitle = {Proceedings of the 49th {ACM} {Technical} {Symposium} on {Computer} {Science} {Education}},
	publisher = {Association for Computing Machinery},
	author = {Krusche, Stephan and Seitz, Andreas},
	month = feb,
	year = {2018},
	keywords = {automated assessment, continuous integration, in-class exercises, instant feedback, interactive exercise instructions, online courses, online editor, programming exercises, version control},
	pages = {284--289},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/VHKAMLK7/Krusche und Seitz - 2018 - ArTEMiS An Automatic Assessment Management System.pdf:application/pdf}
}

@article{robins_learning_2003,
	title = {Learning and {Teaching} {Programming}: {A} {Review} and {Discussion}},
	volume = {13},
	issn = {0899-3408, 1744-5175},
	shorttitle = {Learning and {Teaching} {Programming}},
	url = {https://www.tandfonline.com/doi/full/10.1076/csed.13.2.137.14200},
	doi = {10.1076/csed.13.2.137.14200},
	language = {en},
	number = {2},
	urldate = {2020-06-21},
	journal = {Computer Science Education},
	author = {Robins, Anthony and Rountree, Janet and Rountree, Nathan},
	month = jun,
	year = {2003},
	pages = {137--172},
	file = {Robins et al. - 2003 - Learning and Teaching Programming A Review and Di.pdf:/Users/philippmatthes/Zotero/storage/SBVC7EI7/Robins et al. - 2003 - Learning and Teaching Programming A Review and Di.pdf:application/pdf}
}

@inproceedings{berkling_gamification_2013,
	title = {Gamification of a {Software} {Engineering} course and a detailed analysis of the factors that lead to it's failure},
	doi = {10.1109/ICL.2013.6644642},
	abstract = {This paper describes the setup for a gamified classroom for the subject of Software Engineering. A series of papers have resulted from this work: “Understanding Student Motivation” at CSEDU 2013 [1] and “Bridging the Motivation Gap”, an IGIP SPEED Young Scientist award paper here at ICL 2013 [2]. The intention behind gamifying the course was to increase student engagement and motivation by allowing for independent learning with flexible speed and choice of emphasis. Daniel Pink's [3] motivational theory, which is also found in gamification factors, outlines that autonomy, mastery and purpose lead to these goals. The adopted approach also deals nicely with the vast differences regarding background knowledge and the spread of interest of each of the students. During the latter part of the course a student survey was conducted. Out of 90 students, 59 answered. As a general rule, students did not receive the gamification ideas in a positive light. We examine what went wrong regarding the gamification factors and propose changes for the next iteration of the course.},
	author = {Berkling, Kay and Thomas, Christoph},
	month = sep,
	year = {2013},
	pages = {525--530},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/G647WR97/Berkling und Thomas - 2013 - Gamification of a Software Engineering course and .pdf:application/pdf;Full Text PDF:/Users/philippmatthes/Zotero/storage/W57DCE9U/Berkling und Thomas - 2013 - Gamification of a Software Engineering course and .pdf:application/pdf}
}

@article{connolly_application_2007,
	title = {An application of games-based learning within software engineering},
	volume = {38},
	issn = {1467-8535},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1467-8535.2007.00706.x},
	doi = {10.1111/j.1467-8535.2007.00706.x},
	abstract = {For some time now, computer games have played an important role in both children and adults' leisure activities. While there has been much written on the negative aspects of computer games, it has also been recognised that they have potential advantages and benefits. There is no doubt that computer games are highly engaging and incorporate features that are extremely compelling. It is these highly engaging features of computer games that have attracted the interests of educationalists. The use of games-based learning has been growing for many years now; however, within software engineering, there is still a dearth of empirical evidence to support this approach. In this paper, we examine the literature on the use of computer games to teach software engineering concepts and describe a computer game we have been developing to teach these concepts.},
	language = {en},
	number = {3},
	urldate = {2020-06-21},
	journal = {British Journal of Educational Technology},
	author = {Connolly, Thomas M. and Stansfield, Mark and Hainey, Thomas},
	year = {2007},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1111/j.1467-8535.2007.00706.x},
	pages = {416--428},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/4AN3WWBK/j.1467-8535.2007.00706.html:text/html;Full Text PDF:/Users/philippmatthes/Zotero/storage/X5E9Z2XR/Connolly et al. - 2007 - An application of games-based learning within soft.pdf:application/pdf;Snapshot:/Users/philippmatthes/Zotero/storage/4CMYK9Z5/j.1467-8535.2007.00706.html:text/html;Full Text PDF:/Users/philippmatthes/Zotero/storage/9EHZ3K45/Connolly et al. - 2007 - An application of games-based learning within soft.pdf:application/pdf}
}

@article{pedreira_gamification_2014,
	title = {Gamification in software engineering – {A} systematic mapping},
	volume = {57},
	doi = {10.1016/j.infsof.2014.08.007},
	abstract = {Context
Gamification seeks for improvement of the user’s engagement, motivation, and performance when carrying out a certain task, by means of incorporating game mechanics and elements, thus making that task more attractive. Much research work has studied the application of gamification in software engineering for increasing the engagement and results of developers.

Objective
The objective of this paper is to carry out a systematic mapping of the field of gamification in software engineering in an attempt to characterize the state of the art of this field identifying gaps and opportunities for further research.

Method
We carried out a systematic mapping with a view to finding the primary studies in the existing literature, which were later classified and analyzed according to four criteria: the software process area addressed, the gamification elements used, the type of research method followed, and the type of forum in which they were published. A subjective evaluation of the studies was also carried out to evaluate them in terms of methodology, empirical evidence, integration with the organization, and replicability.

Results
As a result of the systematic mapping we found 29 primary studies, published between January 2011 and June 2014. Most of them focus on software development, and to a lesser extent, requirements, project management, and other support areas. In the main, they consider very simple gamification mechanics such as points and badges, and few provide empirical evidence of the impact of gamification.

Conclusions
Existing research in the field is quite preliminary, and more research effort analyzing the impact of gamification in SE would be needed. Future research work should look at other game mechanics in addition to the basic ones and should tackle software process areas that have not been fully studied, such as requirements, project management, maintenance, or testing. Most studies share a lack of methodological support that would make their proposals replicable in other settings. The integration of gamification with an organization’s existing tools is also an important challenge that needs to be taken up in this field.},
	journal = {Information and Software Technology},
	author = {Pedreira, Oscar and Garcia, Felix and Brisaboa, Nieves and Piattini, Mario},
	month = jan,
	year = {2014},
	keywords = {Gamification, Software engineering, Systematic mapping},
	file = {ScienceDirect Snapshot:/Users/philippmatthes/Zotero/storage/7ECBVJE9/S0950584914001980.html:text/html}
}

@article{alhammad_gamification_2018,
	title = {Gamification in software engineering education: {A} systematic mapping},
	volume = {141},
	issn = {0164-1212},
	shorttitle = {Gamification in software engineering education},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121218300645},
	doi = {10.1016/j.jss.2018.03.065},
	abstract = {The potential of gamification in education is based on the hypothesis that it supports and motivates students and can thus lead to enhanced learning processes and outcomes. Gamification in software engineering (SE) education is in its infancy. However, as SE educators we are particularly interested in understanding how gamification is pollinating our field and the extent to which the above claim is valid in our context. A systematic literature mapping has underscored the difficulty in fully corroborating the above claim because few empirical data are available so far. However, key trends and challenges have been identified. We found that the purpose of applying gamification in the SE field is mostly directly related to improving student engagement and, to a lesser extent, to improving student knowledge, although other targets are the application of SE best practices and socialization. We have also discussed insightful issues regarding the implementation cost of gamification, patterns in the most often used gamification elements, and the SE processes and teaching activities addressed. Of the identified challenges, we should highlight the complexity of deciding which gamification approach to follow, the lack of information for choosing gamification elements and the need to control the impact of gamification.},
	language = {en},
	urldate = {2020-06-21},
	journal = {Journal of Systems and Software},
	author = {Alhammad, Manal M. and Moreno, Ana M.},
	month = jul,
	year = {2018},
	keywords = {Education, Gamification, Software engineering, Systematic mapping},
	pages = {131--150},
	file = {ScienceDirect Snapshot:/Users/philippmatthes/Zotero/storage/PG8V6AGY/S0164121218300645.html:text/html}
}

@inproceedings{mei_teng_game-based_2018,
	title = {Game-{Based} {Learning} in {Requirements} {Engineering}: {An} {Overview}},
	shorttitle = {Game-{Based} {Learning} in {Requirements} {Engineering}},
	doi = {10.1109/IC3e.2018.8632650},
	abstract = {The use of games in the teaching and learning process is not new. It is said to be able to improve students understanding when the subject matters are taught in a less formal but more meaningful way. With the advances of technologies, educational games have evolved into digital games too. They have been introduced into many areas of study such as medicine and engineering. Software engineering is not spared. Since the last few decades, gamification through the use of digital and non-digital games are seen applied in the teaching of various topics of software engineering such as requirements engineering, design and testing. In this paper, a review is specifically made on the games that have been introduced to teach requirements engineering (RE) to the students. Particularly, the types, the learning objectives and the possible classification of the games are presented and discussed. The aim of the review is to identify the current state of RE games with respect to the above. Keyword searching was used to identify the relevant literature to be included in the review. Results showed that the existing RE games can be broadly divided into digital and non-digital games with role playing prevalently used as the game mechanics. Details on the learning objectives of the games and the evaluation performed on the games are also collected and analysed.},
	author = {Mei Teng, Soo and Aris, Hazleen},
	month = nov,
	year = {2018},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/TZUPWZWN/Mei Teng und Aris - 2018 - Game-Based Learning in Requirements Engineering A.pdf:application/pdf}
}

@inproceedings{campolina_games_2018,
	title = {Games and {Gamification} in {Software} {Engineering} {Education}: {A} {Survey} with {Educators}},
	shorttitle = {Games and {Gamification} in {Software} {Engineering} {Education}},
	doi = {10.1109/FIE.2018.8658524},
	abstract = {The use of games and game elements in Software Engineering (SE) education is not new. In fact, their use in Software Engineering education is found in research papers since 1974, with a notorious increase after 2000. However, there is little information about the actual adoption of these approaches in SE education. Therefore, the goal of this paper is to investigate the use of games and game elements in SE education, in the perspective of educators. To achieve this goal, this study propose and analyze the results of a survey answered by 88 SE professors. We sample the participants by inviting 285 educators mined from one hundred well-stablished universities and educational institutions of different regions of Brazil. The goal of the survey is (i) to collect information about the use of games and gamification in classrooms and (ii) to understand the relation of ACM/IEEE knowledge areas and the used game-related methods. The results show that most of the professors are aware of these educational approaches, the games were adopted by only 21 participants and game elements were only adopted by 19 participants. Games are most used to cover “Software Process” and “Project Management”. The most used game elements are Points, Quizzes, and Challenges. The results also show that the main reasons for not adopting the resources are the lack of knowledge, lack of information about relevant games for teaching SE, and the lack of time to plan and include these approaches in the classroom. Finally, results show a positive tendency towards the future adoption of these game-related approaches by the SE professors.},
	author = {Campolina, Pedro and Souza, Maurício and Figueiredo, Eduardo},
	month = oct,
	year = {2018},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/GLKPWD57/Campolina et al. - 2018 - Games and Gamification in Software Engineering Edu.pdf:application/pdf}
}

@article{neto_case_2019,
	title = {Case study of the introduction of game design techniques in software development},
	volume = {13},
	issn = {1751-8814},
	doi = {10.1049/iet-sen.2018.5149},
	abstract = {Software development, in many moments, is an exciting and challenging activity, but it can present itself as a boring endeavour in others. At the same time, the introduction of game elements into efforts such as the teaching of Software Engineering shows that real-world activities can assemble game design elements and that it can make them more engaging. In this work, it is proposed the introduction of game design elements in software development, especially in the Scrum process. For this, elements are included to stimulate adherence to the prescriptions of the process, besides stimulating the execution of more activities by the team, positively impacting the productivity of a project. The authors present the idealised mechanics and the results obtained from the accomplishment of a case study in a software development team in a private company. Overall, the gamification applied to software development stimulated developers to perform their daily tasks, although this result did not generate strong evidence of increased productivity.},
	number = {2},
	journal = {IET Software},
	author = {Neto, Pedro Santos and Medeiros, Danilo Batista and Ibiapina, Irvayne and da Costa Castro, Otávio Cury},
	year = {2019},
	note = {Conference Name: IET Software},
	keywords = {software development team, software engineering, computer aided instruction, computer games, game design elements, case study, challenging activity, educational institutions, exciting activity, game design techniques, game elements, real-world activities, software development management, Software Engineering, teaching},
	pages = {129--143},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/JY5Y6VUC/Neto et al. - 2019 - Case study of the introduction of game design tech.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/9JWB47AR/8680807.html:text/html}
}

@misc{noauthor_pdf_nodate,
	title = {({PDF}) {CleanGame}: {Gamifying} the {Identification} of {Code} {Smells}},
	shorttitle = {({PDF}) {CleanGame}},
	url = {https://www.researchgate.net/publication/335959479_CleanGame_Gamifying_the_Identification_of_Code_Smells},
	abstract = {PDF {\textbar} Refactoring is the process of transforming the internal structure of existing code without changing its observable behavior. Many studies have... {\textbar} Find, read and cite all the research you need on ResearchGate},
	language = {en},
	urldate = {2020-06-21},
	journal = {ResearchGate},
	doi = {http://dx.doi.org/10.1145/3350768.3352490},
	doi = {http://dx.doi.org/10.1145/3350768.3352490},
	note = {Library Catalog: www.researchgate.net},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/KD9VRY8A/335959479_CleanGame_Gamifying_the_Identification_of_Code_Smells.html:text/html}
}

@article{indriasari_gamification_2020,
	title = {Gamification of student peer review in education: {A} systematic literature review},
	issn = {1573-7608},
	shorttitle = {Gamification of student peer review in education},
	url = {https://doi.org/10.1007/s10639-020-10228-x},
	doi = {10.1007/s10639-020-10228-x},
	abstract = {We present the first systematic review of the use of gamification in educational peer review activities. The goal of this work is to understand how gamification has been used to engage students in peer review activities and to summarize the empirical evidence for its effectiveness. Our main contribution is the presentation of a general model of the peer review process that captures the students’ activities and an examination of the specific actions within this model that have been gamified in the current literature. We also summarize the commonly used game mechanics and the context and year level of courses in which prior research has been conducted, along with the reported effects on student behavior. We find that artifact assessment and artifact creation are the two most commonly gamified actions with respect to our peer review model and that the quantity and quality of both the artifacts and the generated feedback are the most popular reward criteria. In addition, Science, Technology, Engineering and Mathematics (STEM) are the discipline areas in which gamified peer review activities are most often reported. In general, while the existing peer review literature reports mostly positive effects of gamification on student engagement, the range of student actions which have been incentivized remains narrow. Key activities, such as student reflection on the feedback received, have been largely unexplored with respect to gamification and thus present useful avenues for future work.},
	language = {en},
	urldate = {2020-06-21},
	journal = {Education and Information Technologies},
	author = {Indriasari, Theresia Devi and Luxton-Reilly, Andrew and Denny, Paul},
	month = may,
	year = {2020}
}

@inproceedings{berkling_presenting_2019,
	title = {Presenting an {Open}-{Source} {Platform} for {Supporting} {Gamified} {Class} {Teaching} with {Peer} {Reviews}},
	doi = {10.1109/EDUCON.2019.8725044},
	abstract = {Gamification in teaching is difficult and choosing the appropriate e-learning platform presents yet another major challenge. Game design thinking goes beyond simple gamification plug-ins to include motivational aspects like autonomy, mastery and purpose as well as personalized affinity spaces. This paper discusses some of the problems with existing platforms and focuses on the design of a light-weight central portal with appropriate workflow and progress visualization that joins remote personalized affinity spaces into the classroom. After discussing the system requirements the paper presents the implementation details of the portal platform. This work contributes an open-source implementation of a basic functional prototype.},
	booktitle = {2019 {IEEE} {Global} {Engineering} {Education} {Conference} ({EDUCON})},
	author = {Berkling, Kay and Neubehler, Katja},
	month = apr,
	year = {2019},
	note = {ISSN: 2165-9567},
	keywords = {Games, computer aided instruction, Task analysis, Tools, serious games (computing), Software Engineering, teaching, Blogs, e-learning platform, Electronic learning, game design, gamification plug-ins, gamified class teaching, human factors, motivational aspects, open-source platform, Peer review, peer reviews, portal platform, portals, Portals, project-based learning, visualization},
	pages = {245--252},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/9FPKK7GF/Berkling und Neubehler - 2019 - Presenting an Open-Source Platform for Supporting .pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/U6LHRJF6/8725044.html:text/html}
}

@inproceedings{dos_santos_cleangame_2019,
	address = {Salvador, Brazil},
	title = {{CleanGame}: {Gamifying} the {Identification} of {Code} {Smells}},
	isbn = {978-1-4503-7651-8},
	shorttitle = {{CleanGame}},
	url = {http://dl.acm.org/citation.cfm?doid=3350768.3352490},
	doi = {10.1145/3350768.3352490},
	abstract = {Refactoring is the process of transforming the internal structure of existing code without changing its observable behavior. Many studies have shown that refactoring increases program maintainability and understandability. Due to these beneﬁts, refactoring is recognized as a best practice in the software development community. However, prior to refactoring activities, developers need to look for refactoring opportunities, i.e., developers need to be able to identify code smells, which essentially are instances of poor design and ill-considered implementation choices that may hinder code maintainability and understandability. However, code smell identiﬁcation is overlooked in the Computer Science curriculum. Recently, Software Engineering educators have started exploring gamiﬁcation, which entails using game elements in non-game contexts, to improve instructional outcomes in educational settings. The potential of gamiﬁcation lies in supporting and motivating students, enhancing the learning process and its outcomes. We set out to evaluate the extent to which such claim is valid in the context of post-training reinforcement. To this end, we devised and implemented CleanGame, which is a gamiﬁed tool that covers one important aspect of the refactoring curriculum: code smell identiﬁcation. We also carried out an experiment involving eighteen participants to probe into the eﬀectiveness of gamiﬁcation in the context of post-training reinforcement. We found that, on average, participants managed to identify twice as much code smells during learning reinforcement with a gamiﬁed approach in comparison to a non-gamiﬁed approach. Moreover, we administered a postexperiment attitudinal survey to the participants. According to the results of such survey, most participants showed a positive attitude towards CleanGame.},
	language = {en},
	urldate = {2020-06-21},
	booktitle = {Proceedings of the {XXXIII} {Brazilian} {Symposium} on {Software} {Engineering}  - {SBES} 2019},
	publisher = {ACM Press},
	author = {dos Santos, Hoyama Maria and Durelli, Vinicius H. S. and Souza, Maurício and Figueiredo, Eduardo and da Silva, Lucas Timoteo and Durelli, Rafael S.},
	year = {2019},
	pages = {437--446},
	file = {dos Santos et al. - 2019 - CleanGame Gamifying the Identification of Code Sm.pdf:/Users/philippmatthes/Zotero/storage/QZT3B3G8/dos Santos et al. - 2019 - CleanGame Gamifying the Identification of Code Sm.pdf:application/pdf}
}

@inproceedings{rojas_code_2016,
	title = {Code {Defenders}: {A} {Mutation} {Testing} {Game}},
	shorttitle = {Code {Defenders}},
	doi = {10.1109/ICSTW.2016.43},
	abstract = {Mutation testing is endorsed by software testing researchers for its unique capability of providing pragmatic estimates of a test suite's fault detection capability, and for guiding testers in improving their test suites. In practice, however, wide-spread adoption of mutation testing is hampered because any non-trivial program results in huge numbers of mutants, many of which are either trivial or equivalent, and thus useless. Trivial mutants reduce the motivation of developers in trusting and using the technique, while equivalent mutants are frustratingly difficult to handle. These problems are exacerbated by insufficient education on testing, which often means that mutation testing is not well understood in practice. These are examples of the types of problems that gamification aims to overcome by making such tedious activities competitive and entertaining. In this paper, we introduce the first steps towards building Code Defenders, a mutation testing game where players take the role of an attacker, who aims to create the most subtle non-equivalent mutants, or a defender, who aims to create strong tests to kill these mutants. The benefits of such an approach are manifold: The game can serve an educational role by engaging learners in mutation testing activities in a fun way. Experienced players will produce strong test suites, capable of detecting even the most subtle bugs that other players can conceive. Equivalent mutants are handled by making them a special part of the gameplay, where points are at stake in duels between attackers and defenders.},
	booktitle = {2016 {IEEE} {Ninth} {International} {Conference} on {Software} {Testing}, {Verification} and {Validation} {Workshops} ({ICSTW})},
	author = {Rojas, José Miguel and Fraser, Gordon},
	month = apr,
	year = {2016},
	keywords = {gamification, software quality, Games, Software, Education, Gamification, program testing, Software testing, software testing, Context, code defender, Conferences, fault detection, Mutation testing, mutation testing game, Testing education},
	pages = {162--167},
	file = {IEEE Xplore Full Text PDF:/Users/philippmatthes/Zotero/storage/6NIC9HRU/Rojas und Fraser - 2016 - Code Defenders A Mutation Testing Game.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/LTKEXPWG/7528958.html:text/html}
}

@inproceedings{sheth_halo_2011,
	address = {Waikiki, Honolulu, HI, USA},
	series = {{GAS} '11},
	title = {{HALO} (highly addictive, socially optimized) software engineering},
	isbn = {978-1-4503-0578-5},
	url = {https://doi.org/10.1145/1984674.1984685},
	doi = {10.1145/1984674.1984685},
	abstract = {In recent years, computer games have become increasingly social and collaborative in nature. Massively multiplayer online games, in which a large number of players collaborate with each other to achieve common goals in the game, have become extremely pervasive. By working together towards a common goal, players become more engrossed in the game. In everyday work environments, this sort of engagement would be beneficial, and is often sought out. We propose an approach to software engineering called HALO that builds upon the properties found in popular games, by turning work into a game environment. Our proposed approach can be viewed as a model for a family of prospective games that would support the software development process. Utilizing operant conditioning and flow theory, we create an immersive software development environment conducive to increased productivity. We describe the mechanics of HALO and how it could fit into typical software engineering processes.},
	urldate = {2020-06-22},
	booktitle = {Proceedings of the 1st {International} {Workshop} on {Games} and {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Sheth, Swapneel and Bell, Jonathan and Kaiser, Gail},
	month = may,
	year = {2011},
	keywords = {games, flow, mmorpg, operant conditioning, quests, social rewards, web 2.0},
	pages = {29--32},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/VISQF5CU/Sheth et al. - 2011 - HALO (highly addictive, socially optimized) softwa.pdf:application/pdf}
}

@inproceedings{elezi_game_2016,
	address = {Edinburgh, Scotland, UK},
	series = {{XP} '16 {Workshops}},
	title = {A game of refactoring: {Studying} the impact of gamification in software refactoring},
	isbn = {978-1-4503-4134-9},
	shorttitle = {A game of refactoring},
	url = {https://doi.org/10.1145/2962695.2962718},
	doi = {10.1145/2962695.2962718},
	abstract = {Software refactoring is an essential skill for developers. It improves the quality of the software and reduces maintenance costs in the long run. In this paper, we investigate the impact that gamification can have on the refactoring process and on the usability of the existing refactoring tools. For this reason we created CodeArena, a gamification system that tracks and rewards refactorings during development. We used CodeArena in an exploratory study which involved 12 students of computer science. Then, we collected the feedback provided by these students via a survey. Although the gamification had less effect than expected, our findings can be useful to practitioners interested in promoting refactoring tools via gamification.},
	urldate = {2020-06-22},
	booktitle = {Proceedings of the {Scientific} {Workshop} {Proceedings} of {XP2016}},
	publisher = {Association for Computing Machinery},
	author = {Elezi, Leonard and Sali, Sara and Demeyer, Serge and Murgia, Alessandro and Pèrez, Javier},
	month = may,
	year = {2016},
	keywords = {Gamification, CodeArena, Eclipse, Refactoring, Survey},
	pages = {1--6},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/XK6PPWBG/Elezi et al. - 2016 - A game of refactoring Studying the impact of gami.pdf:application/pdf}
}

@book{krathwohl_taxonomy_1956,
	address = {New York; New York; London},
	edition = {2nd edition},
	title = {Taxonomy of {Educational} {Objectives}, {Handbook} 1: {Cognitive} {Domain}},
	isbn = {978-0-582-28010-6},
	shorttitle = {Taxonomy of {Educational} {Objectives}, {Handbook} 1},
	abstract = {Using scientific standards of organization and analysis, the various aims and techniques of education are examined with the use of sample exercises and exams},
	language = {Englisch},
	publisher = {Longman},
	author = {Krathwohl, David},
	month = oct,
	year = {1956}
}

@book{bloom_taxonomy_1956,
	title = {Taxonomy of {Educational} {Objectives} - {The} {Classification} of {Educational} {Goals}},
	language = {en},
	urldate = {2020-06-22},
	author = {Bloom, Benjamin S.},
	collaborator = {Engelhart, Max D. and Furst, Edward J. and Hill, Walker H. and Krathwohl, David R.},
	year = {1956},
	file = {Bloom et al -Taxonomy of Educational Objectives.pdf:/Users/philippmatthes/Zotero/storage/7L43DHG6/Bloom et al -Taxonomy of Educational Objectives.pdf:application/pdf}
}

@misc{asmann_modulbeschreibung_2010,
	title = {Modulbeschreibung {Softwaretechnologie}, {INF}-{D}-240},
	url = {https://tu-dresden.de/ing/informatik/ressourcen/dateien/studium/modulbeschreibungen/inf-d-240.pdf?lang=de},
	abstract = {Die Studierenden beherrschen die Methoden zur Entwicklung von
Softwaresystemen. Damit sind die Studierenden in die Lage
versetzt, eine systematische ingenieurtechnische Vorgehensweise
unter Verwendung der Konzepte der Objektorientierung
anzuwenden, insbesondere den Einsatz der Modellierungssprache
Unified Modeling Language (UML) in Analyse, Entwurf und
Implementierung zu beherrschen. Zur praktischen Umsetzung der
Systeme beherrschen die Studierenden den gezielten Einsatz der
Programmiersprache Java, mit besonderer Betonung der
Verwendung von Klassenbibliotheken und Entwurfsmustern.
Grundinformationen zum Projektmanagement und der SoftwareQualitätssicherung runden die Inhalte ab.},
	language = {de},
	author = {Aßmann, Uwe},
	year = {2010},
	file = {inf-d-240.pdf:/Users/philippmatthes/Zotero/storage/TDJMY8FD/inf-d-240.pdf:application/pdf}
}

@book{handke_e-learning_2012,
	title = {E-{Learning}, {E}-{Teaching} und {E}-{Assessment} in der {Hochschullehre}: {Eine} {Anleitung}},
	isbn = {978-3-486-71684-9},
	shorttitle = {E-{Learning}, {E}-{Teaching} und {E}-{Assessment} in der {Hochschullehre}},
	abstract = {Dieses Buch zeigt, wie E-Learning funktionieren kann. Die Autoren sind Hauptakteure eines Teams, das in sich das gesamte Know-How für die Entwicklung und Nutzung verschiedener E-Learning Szenarien vereinigt: von der Konzeption über die Programmierung bis hin zur Nutzung in allen denkbaren Varianten. Daher beleuchtet das jüngste Buch des Marburger „Linguistic Engineering Teams“ nicht nur die verschiedenen Facetten des E-Learnings und E-Teachings, sondern es stellt am Ende jedes Kapitels einen Leitfaden zur Verfügung, der auf Basis funktionierender E-Learning Szenarien darstellt, wie E-Learning und E-Teaching gewinnbringend in der Hochschullehre eingesetzt werden können.},
	language = {de},
	publisher = {Walter de Gruyter},
	author = {Handke, Jürgen and Schäfer, Anna Maria},
	month = dec,
	year = {2012},
	note = {Google-Books-ID: 5ufnBQAAQBAJ},
	keywords = {Education / Curricula, Education / General}
}

@book{crisp_e-assessment_2007,
	address = {London ; New York},
	title = {E-{Assessment} {Handbook}},
	isbn = {978-0-8264-9628-7},
	abstract = {Assessing learning in an online environment is being used by teachers and institutions at an increasing rate. Learners are demanding a more flexible approach to assessment activities just as they have done with learning. This demand will increase as online practice becomes embedded into all schools, further and higher educational courses and corporate training programs. As students are engaging with content in an online environment, they will also need to be assessed using the same tools that are used for the learning experience. This book provides practical guidance to various aspects of online assessment including- types of assessment- choosing the right software- examples of e-assessment over a wide-variety of disciplines- making e-assessment interactive},
	language = {Englisch},
	publisher = {Bloomsbury Academic},
	author = {Crisp, Geoffrey},
	month = jul,
	year = {2007}
}

@book{fowler_refactoring_1999,
	address = {Reading, MA},
	edition = {01},
	title = {Refactoring: {Improving} the {Design} of {Existing} {Code}},
	isbn = {978-0-201-48567-7},
	shorttitle = {Refactoring},
	abstract = {As the application of object technology--particularly the Java programming language--has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, non-optimal applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as refactoring, these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Software, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process. With proper training a skilled system designe},
	language = {Englisch},
	publisher = {Addison Wesley},
	author = {Fowler, Martin and Beck, Kent and Brant, John and Opdyke, William},
	month = jun,
	year = {1999}
}

@book{gloger_scrum_2016,
	title = {Scrum: {Produkte} zuverlässig und schnell entwickeln},
	isbn = {978-3-446-44836-0},
	shorttitle = {Scrum},
	abstract = {- Neu in der 5. Auflage: Scrum ohne Blueprints skalieren- Erweitertes Kapitel zum Thema Führung- Profitieren Sie von zahlreichen Tipps aus der Erfahrung von Boris Gloger, Praxisbeispielen und FallstudienSoftware agil zu entwickeln ist heute die Regel, nicht mehr die Ausnahme. Mittlerweile beginnt die Veränderung an der Spitze der Unternehmen: Die Initiative zum iterativen Weg der Produktentwicklung kommt immer öfter aus den Chefetagen, auch abseits der Softwareentwicklung. So wird Agilität allmählich zum Kulturfaktor – die Prinzipien und die Haltung dahinter zu verstehen, ist dafür die Voraussetzung.Boris Gloger erklärt leicht verständlich die Werte, Regeln, Strukturen und Rollen von Scrum. Sie erfahren, wie Projekte durch Selbstverantwortung aller Projektbeteiligten schneller konkrete und qualitätsvolle Ergebnisse liefern. Und es wird deutlich: Für die Skalierung von Scrum sind keine Schablonen nötig – konsequentes Anwenden der Prinzipien genügt. Ob Sie als Führungskraft, Projektmanager, Teamleiter, Teammitglied oder Kunde an einem Scrum-Projekt beteiligt sind oder wissen wollen, was Scrum eigentlich ist: Hier erhalten Sie Antworten zu den größten Herausforderungen und wertvolle Tipps für das Steuern von Teams. AUS DEM INHALT //Rollen, Meetings und Artefakte // Strategische und operative Planung // Ablauf eines Sprints // Reporting // Qualität durch Professionalität // Scrum skalieren // Selbstorganisation und Führung},
	language = {de},
	publisher = {Carl Hanser Verlag GmbH  Co KG},
	author = {Gloger, Boris},
	month = jun,
	year = {2016},
	note = {Google-Books-ID: LPBCDAAAQBAJ},
	keywords = {Computers / Information Technology}
}

@article{boehm_spiral_1988,
	title = {A spiral model of software development and enhancement},
	volume = {21},
	issn = {1558-0814},
	doi = {10.1109/2.59},
	abstract = {A short description is given of software process models and the issues they address. An outline is given of the process steps involved in the spiral model, an evolving risk-driven approach that provides a framework for guiding the software process, and its application to a software project is shown. A summary is given of the primary advantages and implications involved in using the spiral model and the primary difficulties in using it at its current incomplete level of elaboration.{\textless}{\textgreater}},
	number = {5},
	journal = {Computer},
	author = {Boehm, B. W.},
	month = may,
	year = {1988},
	note = {Conference Name: Computer},
	keywords = {Programming, software engineering, Productivity, Application software, enhancement, Military computing, Navigation, Prototypes, risk-driven approach, software development, software process models, Software prototyping, spiral model, Spirals, Testing},
	pages = {61--72},
	file = {IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/2C642EW3/59.html:text/html}
}

@misc{rouvignac_httpautorefactororg_2020,
	title = {http://autorefactor.org},
	url = {https://autorefactor.org/},
	abstract = {The AutoRefactor project delivers free software that automatically refactor code bases.},
	language = {en},
	urldate = {2020-06-29},
	journal = {Automatically refactor entire code base},
	author = {Rouvignac, Jean-Noël},
	month = jun,
	year = {2020},
	file = {Automatically refactor entire code bases!:/Users/philippmatthes/Zotero/storage/JYH5MD6S/autorefactor.org.html:text/html}
}

@misc{pau_httpwalkmodcom_2020,
	title = {http://walkmod.com/},
	url = {http://walkmod.com/},
	abstract = {Open source tool to fix coding style issues},
	urldate = {2020-06-29},
	journal = {Open Source Tool to fix Java Coding Style Issues},
	author = {Pau, Raquel},
	month = jun,
	year = {2020},
	file = {WalkMod:/Users/philippmatthes/Zotero/storage/K7N6L7F9/walkmod.com.html:text/html}
}

@misc{facebook_httpsgithubcomfacebookarchivepfff_2020,
	title = {https://github.com/facebookarchive/pfff},
	copyright = {View license         ,                 View license},
	url = {https://github.com/facebookarchive/pfff},
	abstract = {Tools for code analysis, visualizations, or style-preserving source transformation.},
	urldate = {2020-06-29},
	publisher = {Facebook Archive},
	author = {{Facebook}},
	month = jun,
	year = {2020},
	note = {original-date: 2010-09-23T05:13:55Z}
}

@misc{bispo_httpsgithubcomspecs-feupkadabra_2020,
	title = {https://github.com/specs-feup/kadabra},
	copyright = {Apache-2.0 License         ,                 Apache-2.0 License},
	url = {https://github.com/specs-feup/kadabra},
	abstract = {Java Source-to-Source Tool based on LARA and Spoon},
	urldate = {2020-06-29},
	publisher = {SPeCS},
	author = {Bispo, João},
	month = jun,
	year = {2020},
	note = {original-date: 2019-07-01T20:57:44Z}
}

@inproceedings{cruz_leafactor_2017,
	title = {Leafactor: {Improving} {Energy} {Efficiency} of {Android} {Apps} via {Automatic} {Refactoring}},
	shorttitle = {Leafactor},
	doi = {10.1109/MOBILESoft.2017.21},
	author = {Cruz, Luís and Abreu, Rui and Rouvignac, Jean-Noel},
	month = may,
	year = {2017},
	pages = {205--206},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/QFZAT3GZ/Cruz et al. - 2017 - Leafactor Improving Energy Efficiency of Android .pdf:application/pdf}
}

@misc{sourcemakingcom_design_2020,
	title = {Design {Patterns} and {Refactoring}},
	url = {https://sourcemaking.com},
	abstract = {Design Patterns and Refactoring articles and guides. Design Patterns video tutorials for newbies. Simple descriptions and full source code examples in Java, C++, C\#, PHP and Delphi.},
	language = {en},
	urldate = {2020-06-30},
	author = {{Sourcemaking.com}},
	month = jun,
	year = {2020},
	note = {Library Catalog: sourcemaking.com},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/PR4V5EFV/the-blob.html:text/html}
}

@misc{refactoringguru_data_2020,
	title = {Data {Class}},
	url = {https://refactoring.guru/smells/data-class},
	abstract = {A data class refers to a class that contains only fields and crude methods for accessing them (getters and setters). These are simply containers for data used by other classes. These classes don’t contain any additional functionality and can’t independently operate on the data that they own.},
	language = {en},
	urldate = {2020-06-30},
	author = {{Refactoring.guru}},
	month = jun,
	year = {2020},
	note = {Library Catalog: refactoring.guru},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/3C5MV53H/data-class.html:text/html}
}

@misc{noauthor_pdf_nodate-1,
	title = {({PDF}) {A} {Survey} on {Software} {Smells}},
	url = {https://www.researchgate.net/publication/322110451_A_Survey_on_Software_Smells},
	abstract = {PDF {\textbar} Context Smells in software systems impair software quality and make them hard to maintain and evolve. The software engineering community has... {\textbar} Find, read and cite all the research you need on ResearchGate},
	language = {en},
	urldate = {2020-06-30},
	journal = {ResearchGate},
	doi = {http://dx.doi.org/10.1016/j.jss.2017.12.034},
	doi = {http://dx.doi.org/10.1016/j.jss.2017.12.034},
	note = {Library Catalog: www.researchgate.net}
}

@article{sharma_survey_2017,
	title = {A {Survey} on {Software} {Smells}},
	volume = {138},
	doi = {10.1016/j.jss.2017.12.034},
	abstract = {Context
Smells in software systems impair software quality and make them hard to maintain and evolve. The software engineering community has explored various dimensions concerning smells and produced extensive research related to smells. The plethora of information poses challenges to the community to comprehend the state-of-the-art tools and techniques.

Objective
We aim to present the current knowledge related to software smells and identify challenges as well as opportunities in the current practices.

Method
We explore the definitions of smells, their causes as well as effects, and their detection mechanisms presented in the current literature. We studied 445 primary studies in detail, synthesized the information, and documented our observations.

Results
The study reveals five possible defining characteristics of smells — indicator, poor solution, violates best-practices, impacts quality, and recurrence. We curate ten common factors that cause smells to occur including lack of skill or awareness and priority to features over quality. We classify existing smell detection methods into five groups — metrics, rules/heuristics, history, machine learning, and optimization-based detection. Challenges in the smells detection include the tools’ proneness to false-positives and poor coverage of smells detectable by existing tools.},
	journal = {Journal of Systems and Software},
	author = {Sharma, Tushar and Spinellis, Diomidis},
	month = dec,
	year = {2017},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/GFP3342V/Sharma und Spinellis - 2017 - A Survey on Software Smells.pdf:application/pdf}
}

@misc{refactoringguru_inline_2020,
	title = {Inline {Class}},
	url = {https://refactoring.guru/inline-class},
	abstract = {Problem: A class does almost nothing and isn’t responsible for anything, and no additional responsibilities are planned for it. Solution: Move all features from the class to another one.},
	language = {en},
	urldate = {2020-06-30},
	author = {{Refactoring.guru}},
	month = jun,
	year = {2020},
	note = {Library Catalog: refactoring.guru},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/PMABFY8L/inline-class.html:text/html}
}

@misc{refactoringguru_shotgun_2020,
	title = {Shotgun {Surgery}},
	url = {https://refactoring.guru/smells/shotgun-surgery},
	abstract = {Making any modifications requires that you make many small changes to many different classes.},
	language = {en},
	urldate = {2020-06-30},
	author = {{Refactoring.guru}},
	month = jun,
	year = {2020},
	note = {Library Catalog: refactoring.guru},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/A7Z85RE6/shotgun-surgery.html:text/html}
}

@inproceedings{palomba_landfill_2015,
	title = {Landfill: {An} {Open} {Dataset} of {Code} {Smells} with {Public} {Evaluation}},
	shorttitle = {Landfill},
	doi = {10.1109/MSR.2015.69},
	abstract = {Code smells are symptoms of poor design and implementation choices that may hinder code comprehension and possibly increase change- and fault-proneness of source code. Several techniques have been proposed in the literature for detecting code smells. These techniques are generally evaluated by comparing their accuracy on a set of detected candidate code smells against a manually-produced oracle. Unfortunately, such comprehensive sets of annotated code smells are not available in the literature with only few exceptions. In this paper we contribute (i) a dataset of 243 instances of five types of code smells identified from 20 open source software projects, (ii) a systematic procedure for validating code smell datasets, (iii) LANDFILL, a Web-based platform for sharing code smell datasets, and (iv) a set of APIs for programmatically accessing LANDFILL's contents. Anyone can contribute to Landfill by (i) improving existing datasets (e.g., Adding missing instances of code smells, flagging possibly incorrectly classified instances), and (ii) sharing and posting new datasets. Landfill is available at www.sesa.unisa.it/landfill/, while the video demonstrating its features in action is available at http://www.sesa.unisa.it/tools/landfill.jsp.},
	booktitle = {2015 {IEEE}/{ACM} 12th {Working} {Conference} on {Mining} {Software} {Repositories}},
	author = {Palomba, Fabio and Di Nucci, Dario and Tufano, Michele and Bavota, Gabriele and Oliveto, Rocco and Poshyvanyk, Denys and De Lucia, Andrea},
	month = may,
	year = {2015},
	note = {ISSN: 2160-1860},
	keywords = {software engineering, Androids, Buildings, candidate code smells, History, Humanoid robots, Internet, LANDFILL, Manuals, open dataset, open source software projects, Software systems, source code (software), systematic procedure, Web-based platform},
	pages = {482--485},
	file = {IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/U7KQAVZZ/7180123.html:text/html;Eingereichte Version:/Users/philippmatthes/Zotero/storage/WA4HF9V7/Palomba et al. - 2015 - Landfill An Open Dataset of Code Smells with Publ.pdf:application/pdf}
}

@misc{checkstyle_project_team_checkstyle_2020,
	title = {checkstyle – {Checkstyle} 8.34},
	url = {https://checkstyle.sourceforge.io/},
	urldate = {2020-07-05},
	author = {{Checkstyle Project Team}},
	month = jun,
	year = {2020},
	file = {checkstyle – Checkstyle 8.34:/Users/philippmatthes/Zotero/storage/BJ6XFHQV/checkstyle.sourceforge.io.html:text/html}
}

@inproceedings{haendler_interactive_2019,
	address = {Heraklion, Crete, Greece},
	title = {An {Interactive} {Tutoring} {System} for {Training} {Software} {Refactoring}:},
	isbn = {978-989-758-367-4},
	shorttitle = {An {Interactive} {Tutoring} {System} for {Training} {Software} {Refactoring}},
	url = {http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0007801101770188},
	doi = {10.5220/0007801101770188},
	language = {en},
	urldate = {2020-07-07},
	booktitle = {Proceedings of the 11th {International} {Conference} on {Computer} {Supported} {Education}},
	publisher = {SCITEPRESS - Science and Technology Publications},
	author = {Haendler, Thorsten and Neumann, Gustaf and Smirnov, Fiodor},
	year = {2019},
	pages = {177--188},
	file = {Haendler et al. - 2019 - An Interactive Tutoring System for Training Softwa.pdf:/Users/philippmatthes/Zotero/storage/A7PTHEDZ/Haendler et al. - 2019 - An Interactive Tutoring System for Training Softwa.pdf:application/pdf}
}

@inproceedings{haendler_framework_2019,
	address = {Vienna, Austria},
	title = {A {Framework} for the {Assessment} and {Training} of {Software} {Refactoring} {Competences}:},
	isbn = {978-989-758-382-7},
	shorttitle = {A {Framework} for the {Assessment} and {Training} of {Software} {Refactoring} {Competences}},
	url = {http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0008350803070316},
	doi = {10.5220/0008350803070316},
	language = {en},
	urldate = {2020-07-07},
	booktitle = {Proceedings of the 11th {International} {Joint} {Conference} on {Knowledge} {Discovery}, {Knowledge} {Engineering} and {Knowledge} {Management}},
	publisher = {SCITEPRESS - Science and Technology Publications},
	author = {Haendler, Thorsten and Neumann, Gustaf},
	year = {2019},
	pages = {307--316},
	file = {Haendler und Neumann - 2019 - A Framework for the Assessment and Training of Sof.pdf:/Users/philippmatthes/Zotero/storage/8HUAACWQ/Haendler und Neumann - 2019 - A Framework for the Assessment and Training of Sof.pdf:application/pdf}
}

@inproceedings{baars_codearena_2019,
	title = {{CodeArena}: {Inspecting} and {Improving} {Code} {Quality} {Metrics} using {Minecraft}},
	shorttitle = {{CodeArena}},
	doi = {10.1109/TechDebt.2019.00023},
	abstract = {To minimize technical debt and increase the maintainability of software, it is essential to make developers aware of what factors influence the maintainability of a codebase. To make the field of code quality and maintenance intuitive to developers, we propose CodeArena, which is an extension to the popular 3D sandbox game called Minecraft. CodeArena converts patterns in a codebase that are considered harmful to monsters in Minecraft, which can then be fought to improve the codebase. This way, the developer can gradually improve the quality of the code, while learning about code quality in an engaging way.},
	booktitle = {2019 {IEEE}/{ACM} {International} {Conference} on {Technical} {Debt} ({TechDebt})},
	author = {Baars, Simon and Meester, Sander},
	month = may,
	year = {2019},
	keywords = {software quality, Games, Software, computer aided instruction, computer games, Education, Gamification, Java, maintainability, technical debt, software maintenance, code quality metrics, Measurement, software metrics, Tools, CodeArena, 3D sandbox game, Code Metrics, Code Quality, codebase, groupware, Maintainability, maintenance intuitive, Minecraft, Rascal, Software Evolution, Three-dimensional displays, Visualization},
	pages = {68--70},
	file = {IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/9BDKAASE/8785986.html:text/html}
}

@book{ullenboom_java_2020,
	edition = {15},
	title = {Java ist auch eine {Insel}: {Das} {Standardwerk} für {Programmierer}. Über 1.000 {Seiten} {Java}-{Wissen}. {Mit} vielen {Beispielen} und Übungen, aktuell zu {Java} 14},
	isbn = {978-3-8362-7737-2},
	shorttitle = {Java ist auch eine {Insel}},
	abstract = {Das Standardwerk zur Java-Programmierung, aktuell zu Java 14  Programmieren mit der Java Platform, Standard Edition 14 Java von A bis Z: Einführung, Praxis, Referenz Von Ausdrücken und Anweisungen zu Klassen und Objekten  Java-Bücher gibt es wie Sand am Meer, aber die Java-Insel ist das Kultbuch für Programmierer und erste Wahl, wenn es um aktuelles und praktisches Java-Wissen geht. Seit über einem Jahrzehnt profitieren Java-Einsteiger, Studenten und Umsteiger von anderen Programmiersprachen gleichermaßen von diesem Standardwerk unter den Java-Büchern. Dozenten und Ausbilder schätzen das Buch für die zahlreichen Beispiele, Aufgaben und Musterlösungen. Leserinnen und Leser feiern es für die verständliche Darstellungsweise und den feinen Humor; Programmierung darf auch Spaß machen! Auf über 1.000 Seiten stellt Autor Christian Ullenboom die Sprachgrundlagen von Java vor und gibt kompakte Einführungen in Spezialthemen wie z. B. Threads, Algorithmen, GUIs oder Dateien und Datenströme. Das Buch ist garniert mit einer Vielzahl an anschaulichen Beispielen aus der Programmierpraxis sowie Aufgaben und Musterlösungen fürs Selbststudium. Der umfangreiche Index und die übersichtliche Struktur des Buches helfen auch unerfahreneren Java-Entwicklern, das passende Thema schnell zu finden oder in der Referenz nachzuschlagen. Keine Frage: Die Java-Insel gehört in das Regal eines jeden Java-Programmierers!  Aus dem Inhalt: Imperative Sprachkonzepte Klassen und Objekte Ausnahmebehandlung Generics Lambda-Ausdrücke und funktionale Programmierung Die Klassenbibliothek Nebenläufige Programmierung Einführung in Datenstrukturen, GUI-Entwicklung, Dateien usw. Die Fachpresse zur Vorauflage: Java magazin: »Die neueste Version des Rheinwerk-Klassikers bietet Java-Programmierern einen Kurzüberblick über diverse Themen und taugt auch als Nachschlagewerk.«},
	language = {Deutsch},
	publisher = {Rheinwerk Computing},
	author = {Ullenboom, Christian},
	month = jun,
	year = {2020}
}

@article{miller_magical_1956,
	title = {The magical number seven, plus or minus two: some limits on our capacity for processing information},
	volume = {63},
	issn = {1939-1471(Electronic),0033-295X(Print)},
	shorttitle = {The magical number seven, plus or minus two},
	doi = {10.1037/h0043158},
	abstract = {A variety of researches are examined from the standpoint of information theory. It is shown that the unaided observer is severely limited in terms of the amount of information he can receive, process, and remember. However, it is shown that by the use of various techniques, e.g., use of several stimulus dimensions, recoding, and various mnemonic devices, this informational bottleneck can be broken. 20 references. (PsycINFO Database Record (c) 2016 APA, all rights reserved)},
	number = {2},
	journal = {Psychological Review},
	author = {Miller, George A.},
	year = {1956},
	note = {Place: US
Publisher: American Psychological Association},
	keywords = {Cognitive Processes, Information Theory},
	pages = {81--97},
	file = {Snapshot:/Users/philippmatthes/Zotero/storage/NT9FPJ6P/1957-02914-001.html:text/html;Eingereichte Version:/Users/philippmatthes/Zotero/storage/A867B37F/Miller - 1956 - The magical number seven, plus or minus two some .pdf:application/pdf}
}

@article{heiberger_design_2014,
	title = {Design of {Diverging} {Stacked} {Bar} {Charts} for {Likert} {Scales} and {Other} {Applications}},
	doi = {10.18637/JSS.V057.I05},
	abstract = {Rating scales, such as Likert scales, are very common in marketing research, customer satisfaction studies, psychometrics, opinion surveys, population studies, and numerous other fields. We recommend diverging stacked bar charts as the primary graphical display technique for Likert and related scales. We also show other applications where diverging stacked bar charts are useful. Many examples of plots of Likert scales are given. We discuss the perceptual and programming issues in constructing these graphs. We present two implementations for diverging stacked bar charts. Most examples in this paper were drawn with the likert function included in the HH package in R. We also have a dashboard in Tableau.},
	author = {Heiberger, R. and Robbins, Naomi B.},
	year = {2014},
	file = {Volltext:/Users/philippmatthes/Zotero/storage/5FGPV92W/Heiberger und Robbins - 2014 - Design of Diverging Stacked Bar Charts for Likert .pdf:application/pdf}
}

@article{nielsen_applying_1995,
	title = {Applying discount usability engineering},
	volume = {12},
	issn = {1937-4194},
	doi = {10.1109/52.363161},
	abstract = {Usability engineering isn't just for the multimillion dollar companies with massive internal test labs. Jakob Nielsen, a distinguished engineer at SunSoft, relates how he and another designer (yes, a two-person project) employed low-cost, easily accessible techniques to perform several useful studies. The techniques, detailed in his recent book Usability Engineering (AP Professional, 1994), are virtually free of complex statistical methods, relying instead on simple observation and interpretation.{\textless}{\textgreater}},
	number = {1},
	journal = {IEEE Software},
	author = {Nielsen, J.},
	month = jan,
	year = {1995},
	note = {Conference Name: IEEE Software},
	keywords = {Sorting, Books, Cognitive science, Design engineering, discount usability engineering, interpretation, observation, Statistical analysis, Sun, System testing, Usability, user interfaces, User interfaces, Web sites},
	pages = {98--100},
	file = {IEEE Xplore Abstract Record:/Users/philippmatthes/Zotero/storage/S5W4ADQP/363161.html:text/html}
}

@book{nielsen_usability_1994,
	title = {Usability {Engineering}},
	isbn = {978-0-12-518406-9},
	abstract = {Written by the author of the best-selling HyperText \& HyperMedia, this book is an excellent guide to the methods of usability engineering. The book provides the tools needed to avoid usability surprises and improve product quality. Step-by-step information on which method to use at various stages during the development lifecycle are included, along with detailed information on how to run a usability test and the unique issues relating to international usability. * Emphasizes cost-effective methods that developers can implement immediately* Instructs readers about which methods to use when, throughout the development lifecycle, which ultimately helps in cost-benefit analysis. * Shows readers how to avoid the four most frequently listed reasons for delay in software projects.* Includes detailed information on how to run a usability test.* Covers unique issues of international usability.* Features an extensive bibliography allowing readers to find additional information.* Written by an internationally renowned expert in the field and the author of the best-selling HyperText \& HyperMedia.},
	language = {en},
	publisher = {Morgan Kaufmann},
	author = {Nielsen, Jakob},
	month = oct,
	year = {1994},
	note = {Google-Books-ID: 95As2OF67f0C},
	keywords = {Computers / Programming / Games, Computers / Computer Graphics / Design, Computers / Human-Computer Interaction (HCI), Computers / Programming Languages / General, Computers / Software Development \& Engineering / General}
}

@article{engler_bugs_2001,
	title = {Bugs as deviant behavior: a general approach to inferring errors in systems code},
	volume = {35},
	issn = {0163-5980},
	shorttitle = {Bugs as deviant behavior},
	url = {https://doi.org/10.1145/502059.502041},
	doi = {10.1145/502059.502041},
	abstract = {A major obstacle to finding program errors in a real system is knowing what correctness rules the system must obey. These rules are often undocumented or specified in an ad hoc manner. This paper demonstrates techniques that automatically extract such checking information from the source code itself, rather than the programmer, thereby avoiding the need for a priori knowledge of system rules.The cornerstone of our approach is inferring programmer "beliefs" that we then cross-check for contradictions. Beliefs are facts implied by code: a dereference of a pointer, p, implies a belief that p is non-null, a call to "unlock(1)" implies that 1 was locked, etc. For beliefs we know the programmer must hold, such as the pointer dereference above, we immediately flag contradictions as errors. For beliefs that the programmer may hold, we can assume these beliefs hold and use a statistical analysis to rank the resulting errors from most to least likely. For example, a call to "spin\_lock" followed once by a call to "spin\_unlock" implies that the programmer may have paired these calls by coincidence. If the pairing happens 999 out of 1000 times, though, then it is probably a valid belief and the sole deviation a probable error. The key feature of this approach is that it requires no a priori knowledge of truth: if two beliefs contradict, we know that one is an error without knowing what the correct belief is.Conceptually, our checkers extract beliefs by tailoring rule "templates" to a system --- for example, finding all functions that fit the rule template "a must be paired with b." We have developed six checkers that follow this conceptual framework. They find hundreds of bugs in real systems such as Linux and OpenBSD. From our experience, they give a dramatic reduction in the manual effort needed to check a large system. Compared to our previous work [9], these template checkers find ten to one hundred times more rule instances and derive properties we found impractical to specify manually.},
	number = {5},
	urldate = {2020-09-10},
	journal = {ACM SIGOPS Operating Systems Review},
	author = {Engler, Dawson and Chen, David Yu and Hallem, Seth and Chou, Andy and Chelf, Benjamin},
	month = oct,
	year = {2001},
	pages = {57--72}
}

@article{joshi_likert_2015,
	title = {Likert {Scale}: {Explored} and {Explained}},
	issn = {2457-1024},
	shorttitle = {Likert {Scale}},
	url = {https://www.journalcjast.com/index.php/CJAST/article/view/7498},
	doi = {10.9734/BJAST/2015/14975},
	language = {en-US},
	urldate = {2020-09-12},
	journal = {Current Journal of Applied Science and Technology},
	author = {Joshi, Ankur and Kale, Saket and Chandel, Satish and Pal, D. K.},
	month = feb,
	year = {2015},
	keywords = {analysis, education, Likert scale, points on scale, Psychometrics},
	pages = {396--403},
	file = {Full Text PDF:/Users/philippmatthes/Zotero/storage/2LC7VKP2/Joshi et al. - 2015 - Likert Scale Explored and Explained.pdf:application/pdf;Snapshot:/Users/philippmatthes/Zotero/storage/2M5NXJIW/7498.html:text/html}
}
